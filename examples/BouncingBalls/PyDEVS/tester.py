"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration) and Sam Pieters (DEVS)

Model author: Simon Van Mierlo+Raphael Mannadiar
Model name:   Bouncing_Balls_Python_Version
Model description:
Tkinter frame with bouncing balls in it.
"""

from sccd.runtime.DEVS_statecharts_core import *
from pypdevs.DEVS import *
from pypdevs.infinity import *
from pypdevs.simulator import *
from sccd.runtime.libs.DEVui import ui
from sccd.runtime.libs.utils import utils
import random

#TODO: problem is that button first needs to be created and then the field cna work properly

class MainAppInstance(RuntimeClassBase):
    def __init__(self, atomdevs):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["fields"] = Association("Field", 0, -1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        MainAppInstance.user_defined_constructor(self)
    
    def user_defined_constructor(self):
        self.nr_of_fields = 0
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /running
        self.states["/running"] = State(1, "/running", self)
        
        # state /running/root
        self.states["/running/root"] = ParallelState(2, "/running/root", self)
        
        # state /running/root/main_behaviour
        self.states["/running/root/main_behaviour"] = State(3, "/running/root/main_behaviour", self)
        
        # state /running/root/main_behaviour/initializing
        self.states["/running/root/main_behaviour/initializing"] = State(4, "/running/root/main_behaviour/initializing", self)
        
        # state /running/root/main_behaviour/running
        self.states["/running/root/main_behaviour/running"] = State(5, "/running/root/main_behaviour/running", self)
        
        # state /running/root/cd_behaviour
        self.states["/running/root/cd_behaviour"] = State(6, "/running/root/cd_behaviour", self)
        
        # state /running/root/cd_behaviour/waiting
        self.states["/running/root/cd_behaviour/waiting"] = State(7, "/running/root/cd_behaviour/waiting", self)
        
        # state /running/root/cd_behaviour/creating
        self.states["/running/root/cd_behaviour/creating"] = State(8, "/running/root/cd_behaviour/creating", self)
        
        # state /running/root/cd_behaviour/check_nr_of_fields
        self.states["/running/root/cd_behaviour/check_nr_of_fields"] = State(9, "/running/root/cd_behaviour/check_nr_of_fields", self)
        self.states["/running/root/cd_behaviour/check_nr_of_fields"].setEnter(self._running_root_cd_behaviour_check_nr_of_fields_enter)
        self.states["/running/root/cd_behaviour/check_nr_of_fields"].setExit(self._running_root_cd_behaviour_check_nr_of_fields_exit)
        
        # state /running/root/cd_behaviour/stopped
        self.states["/running/root/cd_behaviour/stopped"] = State(10, "/running/root/cd_behaviour/stopped", self)
        
        # state /running/stopped
        self.states["/running/stopped"] = State(11, "/running/stopped", self)
        
        # add children
        self.states[""].addChild(self.states["/running"])
        self.states["/running"].addChild(self.states["/running/root"])
        self.states["/running"].addChild(self.states["/running/stopped"])
        self.states["/running/root"].addChild(self.states["/running/root/main_behaviour"])
        self.states["/running/root"].addChild(self.states["/running/root/cd_behaviour"])
        self.states["/running/root/main_behaviour"].addChild(self.states["/running/root/main_behaviour/initializing"])
        self.states["/running/root/main_behaviour"].addChild(self.states["/running/root/main_behaviour/running"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/waiting"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/creating"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/check_nr_of_fields"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/stopped"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/running"]
        self.states["/running"].default_state = self.states["/running/root"]
        self.states["/running/root/main_behaviour"].default_state = self.states["/running/root/main_behaviour/initializing"]
        self.states["/running/root/cd_behaviour"].default_state = self.states["/running/root/cd_behaviour/waiting"]
        
        # transition /running/root/main_behaviour/initializing
        _running_root_main_behaviour_initializing_0 = Transition(self, self.states["/running/root/main_behaviour/initializing"], [self.states["/running/root/main_behaviour/running"]])
        _running_root_main_behaviour_initializing_0.setAction(self._running_root_main_behaviour_initializing_0_exec)
        _running_root_main_behaviour_initializing_0.setTrigger(None)
        self.states["/running/root/main_behaviour/initializing"].addTransition(_running_root_main_behaviour_initializing_0)
        
        # transition /running/root/main_behaviour/running
        _running_root_main_behaviour_running_0 = Transition(self, self.states["/running/root/main_behaviour/running"], [self.states["/running/root/main_behaviour/running"]])
        _running_root_main_behaviour_running_0.setAction(self._running_root_main_behaviour_running_0_exec)
        _running_root_main_behaviour_running_0.setTrigger(Event("button_pressed", None))
        _running_root_main_behaviour_running_0.setGuard(self._running_root_main_behaviour_running_0_guard)
        self.states["/running/root/main_behaviour/running"].addTransition(_running_root_main_behaviour_running_0)
        
        # transition /running/root/cd_behaviour/waiting
        _running_root_cd_behaviour_waiting_0 = Transition(self, self.states["/running/root/cd_behaviour/waiting"], [self.states["/running/root/cd_behaviour/creating"]])
        _running_root_cd_behaviour_waiting_0.setAction(self._running_root_cd_behaviour_waiting_0_exec)
        _running_root_cd_behaviour_waiting_0.setTrigger(Event("create_field", None))
        self.states["/running/root/cd_behaviour/waiting"].addTransition(_running_root_cd_behaviour_waiting_0)
        _running_root_cd_behaviour_waiting_1 = Transition(self, self.states["/running/root/cd_behaviour/waiting"], [self.states["/running/root/cd_behaviour/check_nr_of_fields"]])
        _running_root_cd_behaviour_waiting_1.setAction(self._running_root_cd_behaviour_waiting_1_exec)
        _running_root_cd_behaviour_waiting_1.setTrigger(Event("delete_field", None))
        self.states["/running/root/cd_behaviour/waiting"].addTransition(_running_root_cd_behaviour_waiting_1)
        
        # transition /running/root/cd_behaviour/creating
        _running_root_cd_behaviour_creating_0 = Transition(self, self.states["/running/root/cd_behaviour/creating"], [self.states["/running/root/cd_behaviour/waiting"]])
        _running_root_cd_behaviour_creating_0.setAction(self._running_root_cd_behaviour_creating_0_exec)
        _running_root_cd_behaviour_creating_0.setTrigger(Event("instance_created", None))
        self.states["/running/root/cd_behaviour/creating"].addTransition(_running_root_cd_behaviour_creating_0)
        
        # transition /running/root/cd_behaviour/check_nr_of_fields
        _running_root_cd_behaviour_check_nr_of_fields_0 = Transition(self, self.states["/running/root/cd_behaviour/check_nr_of_fields"], [self.states["/running/root/cd_behaviour/stopped"]])
        _running_root_cd_behaviour_check_nr_of_fields_0.setAction(self._running_root_cd_behaviour_check_nr_of_fields_0_exec)
        _running_root_cd_behaviour_check_nr_of_fields_0.setTrigger(Event("_0after"))
        _running_root_cd_behaviour_check_nr_of_fields_0.setGuard(self._running_root_cd_behaviour_check_nr_of_fields_0_guard)
        self.states["/running/root/cd_behaviour/check_nr_of_fields"].addTransition(_running_root_cd_behaviour_check_nr_of_fields_0)
        _running_root_cd_behaviour_check_nr_of_fields_1 = Transition(self, self.states["/running/root/cd_behaviour/check_nr_of_fields"], [self.states["/running/root/cd_behaviour/waiting"]])
        _running_root_cd_behaviour_check_nr_of_fields_1.setTrigger(None)
        _running_root_cd_behaviour_check_nr_of_fields_1.setGuard(self._running_root_cd_behaviour_check_nr_of_fields_1_guard)
        self.states["/running/root/cd_behaviour/check_nr_of_fields"].addTransition(_running_root_cd_behaviour_check_nr_of_fields_1)
        
        # transition /running/root
        _running_root_0 = Transition(self, self.states["/running/root"], [self.states["/running/stopped"]])
        _running_root_0.setAction(self._running_root_0_exec)
        _running_root_0.setTrigger(Event("stop", None))
        self.states["/running/root"].addTransition(_running_root_0)
    
    def _running_root_cd_behaviour_check_nr_of_fields_enter(self):
        self.addTimer(0, 0.05)
    
    def _running_root_cd_behaviour_check_nr_of_fields_exit(self):
        self.removeTimer(0)
    
    def _running_root_0_exec(self, parameters):
        ui.close_window(ui.window)
    
    def _running_root_main_behaviour_initializing_0_exec(self, parameters):
        self.raiseInternalEvent(Event("create_field", None, []))
    
    def _running_root_main_behaviour_running_0_exec(self, parameters):
        event_name = parameters[0]
        self.raiseInternalEvent(Event("create_field", None, []))
    
    def _running_root_main_behaviour_running_0_guard(self, parameters):
        event_name = parameters[0]
        return event_name == "create_new_field"
    
    def _running_root_cd_behaviour_waiting_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "fields"]))
    
    def _running_root_cd_behaviour_waiting_1_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("delete_instance", None, [self, association_name]))
        self.nr_of_fields -= 1
    
    def _running_root_cd_behaviour_creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
        self.nr_of_fields += 1
    
    def _running_root_cd_behaviour_check_nr_of_fields_0_exec(self, parameters):
        self.raiseInternalEvent(Event("stop", None, []))
    
    def _running_root_cd_behaviour_check_nr_of_fields_0_guard(self, parameters):
        return self.nr_of_fields == 0
    
    def _running_root_cd_behaviour_check_nr_of_fields_1_guard(self, parameters):
        return self.nr_of_fields != 0
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/running"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class MainApp(AtomicDEVS, ObjectManagerBase):
    def __init__(self, name):
        AtomicDEVS.__init__(self, name)
        ObjectManagerBase.__init__(self)
        self.elapsed = 0.0

        self.obj_manager_in = self.addInPort("obj_manager_in")
        self.obj_manager_out = self.addOutPort("obj_manager_out")
        self.input = self.addInPort("input")
        self.outputs = {}
        self.outputs["fields"] = self.addOutPort("fields")

        test = MainAppInstance(self)
        self.instances.add(test)
        self.State = [test]
    
    def extTransition(self, inputs):
        self.simulated_time += self.elapsed
        all_inputs = []
        if self.obj_manager_in in inputs:
            all_inputs.extend(inputs[self.obj_manager_in])
        if self.input in inputs:
            all_inputs.extend(inputs[self.inputs])
        for input in all_inputs:
            if input[3].name == "create_instance":
                self.State.append(MainAppInstance(self))
            if input[3].name == "start_instance":
                self.State[input[2]].start()
            elif input[3].name == "Delete":
                pass
            elif input[3].name == "Associate":
                pass
            elif input[3].name == "Disassociate":
                pass
            # TODO: nog aanvullen en checken
            # TODO: For instance_created, all code that is commented out in the handler should be represented here 
            elif input[3].name == "instance_created" or input[3].name == "instance_started" or input[3].name == "instance_deleted":
                self.State[input[2]].addEvent(input[3])
                self.State[input[2]].associations['fields'].instances[0] = input[3].parameters[0]
        return self.State
    
    def intTransition(self):
        self.to_send = []
        self.stepAll()
        return self.State
    
    def outputFnc(self):
        to_dict = {}
        for sending in self.to_send:
            if sending[0] == None:
                to_dict[self.obj_manager_out] = [sending]
            else:
                the_port = None
                for port in self.OPorts:
                    if port.name == sending[0]:
                        the_port = port
                        break
                
                if the_port in to_dict:
                    to_dict[the_port].append(sending)
                else:
                    to_dict[the_port] = [sending]
        return to_dict
    
    def timeAdvance(self):
        if len(self.to_send) != 0:
            return 0
        idk = self.getEarliestEventTime()
        return idk


class FieldInstance(RuntimeClassBase):
    def __init__(self, atomdevs):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["buttons"] = Association("Button", 0, -1)
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.canvas = None
        self.field_window = None
        
        # call user defined constructor
        FieldInstance.user_defined_constructor(self)
    
    def user_defined_constructor(self):
        self.field_window = ui.new_window(800,600,"BouncingBalls");
        self.canvas = ui.append_canvas(self.field_window,800,600,{'background':'#eee'});
    

        ui.bind_event(self.field_window, ui.EVENTS.WINDOW_CLOSE, self.controller, 'window_close', 'field_ui');
        ui.bind_event(self.field_window, ui.EVENTS.KEY_PRESS, self.controller, 'key_press', 'field_ui');
        ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_RIGHT_CLICK,    self.controller, 'right_click', 'field_ui');
        ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_MOVE, self.controller, 'mouse_move', 'field_ui');
        ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_RELEASE, self.controller, 'mouse_release','field_ui');

        #ui.bind_event(self.field_window, ui.EVENTS.WINDOW_CLOSE, self.controller, 'window_close', self.inports['field_ui']);
        #ui.bind_event(self.field_window, ui.EVENTS.KEY_PRESS, self.controller, 'key_press', self.inports['field_ui']);
        #ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_RIGHT_CLICK,    self.controller, 'right_click', self.inports['field_ui']);
        #ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_MOVE, self.controller, 'mouse_move', self.inports['field_ui']);
        #ui.bind_event(self.canvas.element, ui.EVENTS.MOUSE_RELEASE, self.controller, 'mouse_release', self.inports['field_ui']);
    
    def user_defined_destructor(self):
        ui.close_window(self.field_window);
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /root
        self.states["/root"] = State(1, "/root", self)
        
        # state /root/waiting
        self.states["/root/waiting"] = State(2, "/root/waiting", self)
        
        # state /root/initializing
        self.states["/root/initializing"] = State(3, "/root/initializing", self)
        
        # state /root/creating
        self.states["/root/creating"] = State(4, "/root/creating", self)
        
        # state /root/packing
        self.states["/root/packing"] = State(5, "/root/packing", self)
        
        # state /root/running
        self.states["/root/running"] = ParallelState(6, "/root/running", self)
        
        # state /root/running/main_behaviour
        self.states["/root/running/main_behaviour"] = State(7, "/root/running/main_behaviour", self)
        
        # state /root/running/main_behaviour/running
        self.states["/root/running/main_behaviour/running"] = State(8, "/root/running/main_behaviour/running", self)
        
        # state /root/running/main_behaviour/creating
        self.states["/root/running/main_behaviour/creating"] = State(9, "/root/running/main_behaviour/creating", self)
        
        # state /root/running/deleting_behaviour
        self.states["/root/running/deleting_behaviour"] = State(10, "/root/running/deleting_behaviour", self)
        
        # state /root/running/deleting_behaviour/running
        self.states["/root/running/deleting_behaviour/running"] = State(11, "/root/running/deleting_behaviour/running", self)
        
        # state /root/running/child_behaviour
        self.states["/root/running/child_behaviour"] = State(12, "/root/running/child_behaviour", self)
        
        # state /root/running/child_behaviour/listening
        self.states["/root/running/child_behaviour/listening"] = State(13, "/root/running/child_behaviour/listening", self)
        
        # state /root/running/deleting_balls_behaviour
        self.states["/root/running/deleting_balls_behaviour"] = State(14, "/root/running/deleting_balls_behaviour", self)
        
        # state /root/running/deleting_balls_behaviour/listening
        self.states["/root/running/deleting_balls_behaviour/listening"] = State(15, "/root/running/deleting_balls_behaviour/listening", self)
        
        # state /root/deleting
        self.states["/root/deleting"] = State(16, "/root/deleting", self)
        
        # state /root/deleted
        self.states["/root/deleted"] = State(17, "/root/deleted", self)
        
        # add children
        self.states[""].addChild(self.states["/root"])
        self.states["/root"].addChild(self.states["/root/waiting"])
        self.states["/root"].addChild(self.states["/root/initializing"])
        self.states["/root"].addChild(self.states["/root/creating"])
        self.states["/root"].addChild(self.states["/root/packing"])
        self.states["/root"].addChild(self.states["/root/running"])
        self.states["/root"].addChild(self.states["/root/deleting"])
        self.states["/root"].addChild(self.states["/root/deleted"])
        self.states["/root/running"].addChild(self.states["/root/running/main_behaviour"])
        self.states["/root/running"].addChild(self.states["/root/running/deleting_behaviour"])
        self.states["/root/running"].addChild(self.states["/root/running/child_behaviour"])
        self.states["/root/running"].addChild(self.states["/root/running/deleting_balls_behaviour"])
        self.states["/root/running/main_behaviour"].addChild(self.states["/root/running/main_behaviour/running"])
        self.states["/root/running/main_behaviour"].addChild(self.states["/root/running/main_behaviour/creating"])
        self.states["/root/running/deleting_behaviour"].addChild(self.states["/root/running/deleting_behaviour/running"])
        self.states["/root/running/child_behaviour"].addChild(self.states["/root/running/child_behaviour/listening"])
        self.states["/root/running/deleting_balls_behaviour"].addChild(self.states["/root/running/deleting_balls_behaviour/listening"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/root"]
        self.states["/root"].default_state = self.states["/root/waiting"]
        self.states["/root/running/main_behaviour"].default_state = self.states["/root/running/main_behaviour/running"]
        self.states["/root/running/deleting_behaviour"].default_state = self.states["/root/running/deleting_behaviour/running"]
        self.states["/root/running/child_behaviour"].default_state = self.states["/root/running/child_behaviour/listening"]
        self.states["/root/running/deleting_balls_behaviour"].default_state = self.states["/root/running/deleting_balls_behaviour/listening"]
        
        # transition /root/waiting
        _root_waiting_0 = Transition(self, self.states["/root/waiting"], [self.states["/root/initializing"]])
        _root_waiting_0.setAction(self._root_waiting_0_exec)
        _root_waiting_0.setTrigger(Event("set_association_name", None))
        self.states["/root/waiting"].addTransition(_root_waiting_0)
        
        # transition /root/initializing
        _root_initializing_0 = Transition(self, self.states["/root/initializing"], [self.states["/root/creating"]])
        _root_initializing_0.setAction(self._root_initializing_0_exec)
        _root_initializing_0.setTrigger(None)
        self.states["/root/initializing"].addTransition(_root_initializing_0)
        
        # transition /root/creating
        _root_creating_0 = Transition(self, self.states["/root/creating"], [self.states["/root/packing"]])
        _root_creating_0.setAction(self._root_creating_0_exec)
        _root_creating_0.setTrigger(Event("instance_created", None))
        self.states["/root/creating"].addTransition(_root_creating_0)
        
        # transition /root/packing
        _root_packing_0 = Transition(self, self.states["/root/packing"], [self.states["/root/running"]])
        _root_packing_0.setTrigger(Event("button_created", None))
        self.states["/root/packing"].addTransition(_root_packing_0)
        
        # transition /root/running/main_behaviour/running
        _root_running_main_behaviour_running_0 = Transition(self, self.states["/root/running/main_behaviour/running"], [self.states["/root/running/main_behaviour/creating"]])
        _root_running_main_behaviour_running_0.setAction(self._root_running_main_behaviour_running_0_exec)
        _root_running_main_behaviour_running_0.setTrigger(Event("right_click", self.getInPortName("field_ui")))
        self.states["/root/running/main_behaviour/running"].addTransition(_root_running_main_behaviour_running_0)
        
        # transition /root/running/main_behaviour/creating
        _root_running_main_behaviour_creating_0 = Transition(self, self.states["/root/running/main_behaviour/creating"], [self.states["/root/running/main_behaviour/running"]])
        _root_running_main_behaviour_creating_0.setAction(self._root_running_main_behaviour_creating_0_exec)
        _root_running_main_behaviour_creating_0.setTrigger(Event("instance_created", None))
        self.states["/root/running/main_behaviour/creating"].addTransition(_root_running_main_behaviour_creating_0)
        
        # transition /root/running/deleting_behaviour/running
        _root_running_deleting_behaviour_running_0 = Transition(self, self.states["/root/running/deleting_behaviour/running"], [self.states["/root/running/deleting_behaviour/running"]])
        _root_running_deleting_behaviour_running_0.setAction(self._root_running_deleting_behaviour_running_0_exec)
        _root_running_deleting_behaviour_running_0.setTrigger(Event("delete_ball", None))
        self.states["/root/running/deleting_behaviour/running"].addTransition(_root_running_deleting_behaviour_running_0)
        
        # transition /root/running/child_behaviour/listening
        _root_running_child_behaviour_listening_0 = Transition(self, self.states["/root/running/child_behaviour/listening"], [self.states["/root/running/child_behaviour/listening"]])
        _root_running_child_behaviour_listening_0.setAction(self._root_running_child_behaviour_listening_0_exec)
        _root_running_child_behaviour_listening_0.setTrigger(Event("button_pressed", None))
        self.states["/root/running/child_behaviour/listening"].addTransition(_root_running_child_behaviour_listening_0)
        
        # transition /root/running/deleting_balls_behaviour/listening
        _root_running_deleting_balls_behaviour_listening_0 = Transition(self, self.states["/root/running/deleting_balls_behaviour/listening"], [self.states["/root/running/deleting_balls_behaviour/listening"]])
        _root_running_deleting_balls_behaviour_listening_0.setAction(self._root_running_deleting_balls_behaviour_listening_0_exec)
        _root_running_deleting_balls_behaviour_listening_0.setTrigger(Event("key_press", self.getInPortName("field_ui")))
        _root_running_deleting_balls_behaviour_listening_0.setGuard(self._root_running_deleting_balls_behaviour_listening_0_guard)
        self.states["/root/running/deleting_balls_behaviour/listening"].addTransition(_root_running_deleting_balls_behaviour_listening_0)
        
        # transition /root/deleting
        _root_deleting_0 = Transition(self, self.states["/root/deleting"], [self.states["/root/deleted"]])
        _root_deleting_0.setAction(self._root_deleting_0_exec)
        _root_deleting_0.setTrigger(None)
        self.states["/root/deleting"].addTransition(_root_deleting_0)
        
        # transition /root/running
        _root_running_0 = Transition(self, self.states["/root/running"], [self.states["/root/deleting"]])
        _root_running_0.setAction(self._root_running_0_exec)
        _root_running_0.setTrigger(Event("window_close", self.getInPortName("field_ui")))
        self.states["/root/running"].addTransition(_root_running_0)
    
    def _root_running_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("delete_instance", None, [self, "buttons"]))
        self.big_step.outputEventOM(Event("delete_instance", None, [self, "balls"]))
    
    def _root_waiting_0_exec(self, parameters):
        association_name = parameters[0]
        self.association_name = association_name
    
    def _root_initializing_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "buttons", "Button", self, 'create_new_field', 'Spawn New Window']))
    
    def _root_creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _root_running_main_behaviour_running_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEventOM(Event("create_instance", None, [self, "balls", "Ball", self.canvas, x, y]))
    
    def _root_running_main_behaviour_creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
    
    def _root_running_deleting_behaviour_running_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("delete_instance", None, [self, association_name]))
    
    def _root_running_child_behaviour_listening_0_exec(self, parameters):
        event_name = parameters[0]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("button_pressed", None, [event_name])]))
    
    def _root_running_deleting_balls_behaviour_listening_0_exec(self, parameters):
        key = parameters[0]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'balls', Event("delete_self", None, [])]))
    
    def _root_running_deleting_balls_behaviour_listening_0_guard(self, parameters):
        key = parameters[0]
        return key == ui.KEYCODES.DELETE
    
    def _root_deleting_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("delete_field", None, [self.association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/root"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Field(AtomicDEVS, ObjectManagerBase):
    def __init__(self, name):
        AtomicDEVS.__init__(self, name)
        ObjectManagerBase.__init__(self)
        self.State = []
        self.obj_manager_in = self.addInPort("obj_manager_in")
        self.obj_manager_out = self.addOutPort("obj_manager_out")
        self.input = self.addInPort("input")
        self.outputs = {}
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["buttons"] = self.addOutPort("buttons")
        self.outputs["parent"] = self.addOutPort("parent")
        self.field_ui = self.addInPort("field_ui")
    
    def extTransition(self, inputs):
        self.simulated_time += self.elapsed
        all_inputs = []
        if self.obj_manager_in in inputs:
            all_inputs.extend(inputs[self.obj_manager_in])
        if self.input in inputs:
            all_inputs.extend(inputs[self.input])
        if self.field_ui in inputs:
            all_inputs.extend(inputs[self.field_ui])
        for input in all_inputs:
            #TODO: checking if input is string is a quick fix because realtime_interrupt in this version can 
            if isinstance(input, str):
                # TODO: can't just do add event because maybe need to be a broadcast, in this case just narrow event
                tem = eval(input)
                self.addInput(tem)
            elif input[3].name == "create_instance":
                test = FieldInstance(self)
                self.instances.add(test)
                self.State.append(test)

                # TODO: the target cannot be called easily, therefore don't send it over the objectmanager or do something else
                # TODO: make a new link for the association 
                ev = Event("instance_created", None, [input[0]+"["+str(len(self.State) - 1)+"]"])
                self.to_send.append(("Field", "MainApp", input[2], ev))

            elif input[3].name == "start_instance":
                self.State[input[2]].start()

                ev = Event("instance_started", None, parameters = ["fields[0]"])
                self.to_send.append((input[0], "MainApp", input[2], ev))

                #self.State[input[2]].addEvent(Event("instance_started", parameters = []))
                #source.addEvent(Event("instance_started", parameters = [parameters[1]]))
            elif input[3].name == "Delete":
                pass
            elif input[3].name == "Associate":
                pass
            elif input[3].name == "Disassociate":
                pass
            elif input[3].name == "set_association_name":
                #self.State[input[2]].addEvent(input[3])
                #self.State[input[2]].associations['fields'].instances[0] = input[3].parameters[0]

                ev = input[3] 
                self.addInput(ev, force_internal=True)


                #to_send_event = Event(cast_event.name, i["instance"].narrow_cast_port, cast_event.parameters)
                #i["instance"].controller.addInput(to_send_event, force_internal=True)
        return self.State
    
    def intTransition(self):
        self.to_send = []
        self.handleInput()
        self.stepAll()
        return self.State
    
    def outputFnc(self):
        to_dict = {}
        for sending in self.to_send:
            to_dict[self.obj_manager_out] = [sending]
        return to_dict
    
    def timeAdvance(self):
        if len(self.to_send) != 0:
            return 0
        idk = self.getEarliestEventTime()
        return idk
    
    def handleInput(self):
        while not self.input_queue.isEmpty():
            event_time = self.input_queue.getEarliestTime()
            e = self.input_queue.pop()
            
            #TODO: tot nu toe zal dit werken maar niet 
            #input_port = self.input_ports[e.getPort()]
            input_port = e.getPort()

            #target_instance = input_port.instance
            target_instance = self.State[0]
            if target_instance == None:
                self.broadcast(e, event_time - self.simulated_time)
            else:
                target_instance.addEvent(e, event_time - self.simulated_time)

    def addInput(self, input_event_list, time_offset = 0, force_internal=False):
        # force_internal is for narrow_cast events, otherwise these would arrive as external events (on the current wall-clock time)
        if not isinstance(input_event_list, list):
            input_event_list = [input_event_list]

        for e in input_event_list:
            if e.getName() == "":
                raise InputException("Input event can't have an empty name.")
            
            #if e.getPort() not in self.IPorts:
            #    raise InputException("Input port mismatch, no such port: " + e.getPort() + ".")
                
            if force_internal:
                self.input_queue.add((0 if self.simulated_time is None else self.simulated_time) + time_offset, e)
            else:
                # TODO; changed this from self.accurate_time.get_wct() to self.simulated_time
                self.input_queue.add((0 if self.simulated_time is None else 0) + time_offset, e)


class ButtonInstance(RuntimeClassBase):
    def __init__(self, atomdevs, parent, event_name, button_text):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["parent"] = Association("Field", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        ButtonInstance.user_defined_constructor(self, parent, event_name, button_text)
    
    def user_defined_constructor(self, parent, event_name, button_text):
        self.event_name = event_name;
        button = ui.append_button(parent.field_window, event_name);
        ui.bind_event(button.element, ui.EVENTS.MOUSE_CLICK, self.controller, 'mouse_click', self.inports['button_ui']);
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /initializing
        self.states["/initializing"] = State(1, "/initializing", self)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # add children
        self.states[""].addChild(self.states["/initializing"])
        self.states[""].addChild(self.states["/running"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/initializing"]
        
        # transition /initializing
        _initializing_0 = Transition(self, self.states["/initializing"], [self.states["/running"]])
        _initializing_0.setAction(self._initializing_0_exec)
        _initializing_0.setTrigger(None)
        self.states["/initializing"].addTransition(_initializing_0)
        
        # transition /running
        _running_0 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_0.setAction(self._running_0_exec)
        _running_0.setTrigger(Event("mouse_click", self.getInPortName("button_ui")))
        _running_0.setGuard(self._running_0_guard)
        self.states["/running"].addTransition(_running_0)
    
    def _initializing_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("button_created", None, [])]))
    
    def _running_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("button_pressed", None, [self.event_name])]))
    
    def _running_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/initializing"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)






class Button(AtomicDEVS, ObjectManagerBase):
    def __init__(self, name):
        AtomicDEVS.__init__(self, name)
        ObjectManagerBase.__init__(self)
        self.State = []
        self.obj_manager_in = self.addInPort("obj_manager_in")
        self.obj_manager_out = self.addOutPort("obj_manager_out")
        self.input = self.addInPort("input")
        self.outputs = {}
        self.outputs["parent"] = self.addOutPort("parent")
        self.button_ui = self.addInPort("button_ui")
    
    def extTransition(self, inputs):
        self.simulated_time += self.elapsed
        all_inputs = []
        if self.obj_manager_in in inputs:
            all_inputs.extend(inputs[self.obj_manager_in])
        if self.input in inputs:
            all_inputs.extend(inputs[self.input])
        if self.button_ui in inputs:
            all_inputs.extend(inputs[self.field_ui])
        for input in all_inputs:
            #TODO: checking if input is string is a quick fix because realtime_interrupt in this version can 
            if isinstance(input, str):
                # TODO: can't just do add event because maybe need to be a broadcast, in this case just narrow event
                tem = eval(input)
                self.addInput(tem)


            elif input[3].name == "create_instance":
                test = ButtonInstance(self, None, input[3].parameters[0], input[3].parameters[1])
                self.instances.add(test)
                self.State.append(test)

                # TODO: the target cannot be called easily, therefore don't send it over the objectmanager or do something else
                # TODO: make a new link for the association 
                ev = Event("instance_created", None, [input[0]+"["+str(len(self.State) - 1)+"]"])
                self.to_send.append(("Button", "Field", input[2], ev))

            elif input[3].name == "start_instance":
                self.State[input[2]].start()

                ev = Event("instance_started", None, parameters = ["buttons[0]"])
                self.to_send.append((input[0], "Field", input[2], ev))

                #self.State[input[2]].addEvent(Event("instance_started", parameters = []))
                #source.addEvent(Event("instance_started", parameters = [parameters[1]]))
            elif input[3].name == "Delete":
                pass
            elif input[3].name == "Associate":
                pass
            elif input[3].name == "Disassociate":
                pass
            elif input[3].name == "set_association_name":
                ev = input[3] 
                self.addInput(ev, force_internal=True)
        return self.State
    
    def intTransition(self):
        self.to_send = []
        self.handleInput()
        self.stepAll()
        return self.State
    
    def outputFnc(self):
        to_dict = {}
        for sending in self.to_send:
            to_dict[self.obj_manager_out] = [sending]
        return to_dict
    
    def timeAdvance(self):
        if len(self.to_send) != 0:
            return 0
        idk = self.getEarliestEventTime()
        return idk
    
    def handleInput(self):
        while not self.input_queue.isEmpty():
            event_time = self.input_queue.getEarliestTime()
            e = self.input_queue.pop()
            
            #TODO: tot nu toe zal dit werken maar niet 
            #input_port = self.input_ports[e.getPort()]
            input_port = e.getPort()

            #target_instance = input_port.instance
            target_instance = self.State[0]
            if target_instance == None:
                self.broadcast(e, event_time - self.simulated_time)
            else:
                target_instance.addEvent(e, event_time - self.simulated_time)

    def addInput(self, input_event_list, time_offset = 0, force_internal=False):
        # force_internal is for narrow_cast events, otherwise these would arrive as external events (on the current wall-clock time)
        if not isinstance(input_event_list, list):
            input_event_list = [input_event_list]

        for e in input_event_list:
            if e.getName() == "":
                raise InputException("Input event can't have an empty name.")
            
            #if e.getPort() not in self.IPorts:
            #    raise InputException("Input port mismatch, no such port: " + e.getPort() + ".")
                
            if force_internal:
                self.input_queue.add((0 if self.simulated_time is None else self.simulated_time) + time_offset, e)
            else:
                # TODO; changed this from self.accurate_time.get_wct() to self.simulated_time
                self.input_queue.add((0 if self.simulated_time is None else 0) + time_offset, e)

class BallInstance(RuntimeClassBase):
    def __init__(self):
        RuntimeClassBase.__init__(self)
        self.associations = {}
        self.associations["parent"] = Association("Field", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.canvas = None
        
        # call user defined constructor
        BallInstance.user_defined_constructor(self, canvas, x, y)
    
    def user_defined_constructor(self, canvas, x, y):
        self.canvas = canvas;
        self.r = 20.0;
        self.vel = {'x': random.uniform(-5.0, 5.0), 'y': random.uniform(-5.0, 5.0)};
        self.mouse_pos = {};
        self.smooth = 0.4; # value between 0 and 1
        
        circle = self.canvas.add_circle(x, y, self.r, {'fill':'#000'});
        ui.bind_event(circle, ui.EVENTS.MOUSE_PRESS, self.controller, 'mouse_press', self.inports["ball_ui"]);
        ui.bind_event(circle, ui.EVENTS.MOUSE_MOVE, self.controller, 'mouse_move', self.inports['ball_ui']);
        ui.bind_event(circle, ui.EVENTS.MOUSE_RELEASE, self.controller, 'mouse_release', self.inports['ball_ui']);
        self.element = circle;
    
    def user_defined_destructor(self):
        self.canvas.remove_element(self.element);
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /main_behaviour
        self.states["/main_behaviour"] = State(1, "/main_behaviour", self)
        
        # state /main_behaviour/initializing
        self.states["/main_behaviour/initializing"] = State(2, "/main_behaviour/initializing", self)
        
        # state /main_behaviour/bouncing
        self.states["/main_behaviour/bouncing"] = State(3, "/main_behaviour/bouncing", self)
        self.states["/main_behaviour/bouncing"].setEnter(self._main_behaviour_bouncing_enter)
        self.states["/main_behaviour/bouncing"].setExit(self._main_behaviour_bouncing_exit)
        
        # state /main_behaviour/dragging
        self.states["/main_behaviour/dragging"] = State(4, "/main_behaviour/dragging", self)
        
        # state /main_behaviour/selected
        self.states["/main_behaviour/selected"] = State(5, "/main_behaviour/selected", self)
        
        # state /deleted
        self.states["/deleted"] = State(6, "/deleted", self)
        
        # add children
        self.states[""].addChild(self.states["/main_behaviour"])
        self.states[""].addChild(self.states["/deleted"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/initializing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/bouncing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/dragging"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/selected"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/main_behaviour"]
        self.states["/main_behaviour"].default_state = self.states["/main_behaviour/initializing"]
        
        # transition /main_behaviour/initializing
        _main_behaviour_initializing_0 = Transition(self, self.states["/main_behaviour/initializing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_initializing_0.setAction(self._main_behaviour_initializing_0_exec)
        _main_behaviour_initializing_0.setTrigger(Event("set_association_name", None))
        self.states["/main_behaviour/initializing"].addTransition(_main_behaviour_initializing_0)
        
        
        # transition /main_behaviour/bouncing
        _main_behaviour_bouncing_0 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_0.setAction(self._main_behaviour_bouncing_0_exec)
        _main_behaviour_bouncing_0.setTrigger(Event("_0after"))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_0)
        _main_behaviour_bouncing_1 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/selected"]])
        _main_behaviour_bouncing_1.setAction(self._main_behaviour_bouncing_1_exec)
        _main_behaviour_bouncing_1.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_bouncing_1.setGuard(self._main_behaviour_bouncing_1_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_1)
        
        # transition /main_behaviour/dragging
        _main_behaviour_dragging_0 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_dragging_0.setAction(self._main_behaviour_dragging_0_exec)
        _main_behaviour_dragging_0.setTrigger(Event("mouse_move", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_0)
        _main_behaviour_dragging_1 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_dragging_1.setAction(self._main_behaviour_dragging_1_exec)
        _main_behaviour_dragging_1.setTrigger(Event("mouse_release", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_1)
        
        # transition /main_behaviour/selected
        _main_behaviour_selected_0 = Transition(self, self.states["/main_behaviour/selected"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_selected_0.setAction(self._main_behaviour_selected_0_exec)
        _main_behaviour_selected_0.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_selected_0.setGuard(self._main_behaviour_selected_0_guard)
        self.states["/main_behaviour/selected"].addTransition(_main_behaviour_selected_0)
        _main_behaviour_selected_1 = Transition(self, self.states["/main_behaviour/selected"], [self.states["/deleted"]])
        _main_behaviour_selected_1.setAction(self._main_behaviour_selected_1_exec)
        _main_behaviour_selected_1.setTrigger(Event("delete_self", None))
        self.states["/main_behaviour/selected"].addTransition(_main_behaviour_selected_1)
    
    def _main_behaviour_bouncing_enter(self):
        self.addTimer(0, (20 - self.getSimulatedTime() % 20) / 1000.0)
    
    def _main_behaviour_bouncing_exit(self):
        self.removeTimer(0)
    
    def _main_behaviour_initializing_0_exec(self, parameters):
        association_name = parameters[0]
        self.association_name = association_name
    
    def _main_behaviour_bouncing_0_exec(self, parameters):
        pos = self.element.get_position();
        if pos.x-self.r <= 0 or pos.x+self.r >= self.canvas.get_width():
            self.vel['x'] = -self.vel['x'];
        if pos.y-self.r <= 0 or pos.y+self.r >= self.canvas.get_height():
            self.vel['y'] = -self.vel['y'];
        self.element.move(self.vel['x'], self.vel['y']);
    
    def _main_behaviour_bouncing_1_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.element.set_color("#ff0");
    
    def _main_behaviour_bouncing_1_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_dragging_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        dx = x - self.mouse_pos['x'];
        dy = y - self.mouse_pos['y'];
        
        self.element.move(dx, dy);
        
        # keep ball within boundaries
        pos = self.element.get_position();
        if pos.x-self.r <= 0 :
            pos.x = self.r + 1;
        elif pos.x+self.r >= self.canvas.width :
            pos.x = self.canvas.width-self.r-1;
        if pos.y-self.r <= 0 :
            pos.y = self.r + 1;
        elif pos.y+self.r >= self.canvas.height :
            pos.y = self.canvas.height-self.r-1;
        self.element.set_position(pos.x, pos.y);
        self.mouse_pos = {'x':x, 'y':y};
        self.vel = {
            'x': (1-self.smooth)*dx + self.smooth*self.vel['x'],
            'y': (1-self.smooth)*dy + self.smooth*self.vel['y']
        };
    
    def _main_behaviour_dragging_1_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        self.element.set_color("#f00");
    
    def _main_behaviour_selected_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.mouse_pos = {'x':x, 'y':y};
    
    def _main_behaviour_selected_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_selected_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("delete_ball", None, [self.association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/main_behaviour"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Ball(AtomicDEVS):
    def __init__(self, name):
        AtomicDEVS.__init__(self, name)
        self.State = []
        self.obj_manager_in = self.addInPort("obj_manager_in")
        self.obj_manager_out = self.addOutPort("obj_manager_out")
        self.input = self.addInPort("input")
        self.outputs = {}
        self.outputs["parent"] = self.addOutPort("parent")
        self.ball_ui = self.addInPort("ball_ui")
    
    def extTransition(self, inputs):
        all_inputs = inputs[self.obj_manager_in]
        for input in all_inputs:
            if input[0] == "Initialize":
                self.State.append(BallInstance())
            if input[0] == "Start":
                self.State[input[1]].start()
            elif input[0] == "Delete":
                pass
            elif input[0] == "Associate":
                pass
            elif input[0] == "Disassociate":
                pass
        return self.state
    
    def intTransition(self):
        return self.state
    
    def outputFnc(self):
        return {}
    
    def timeAdvance(self):
        return INFINITY

class ObjectManagerState:
    def __init__(self):
        # tuple is in the form of (source, target, id, message)
        self.to_send = [(None, "MainApp", 0, Event("start_instance", None, None))]


class ObjectManager(AtomicDEVS):
    def __init__(self, name):
        AtomicDEVS.__init__(self, name)
        self.State = ObjectManagerState()
        self.input = self.addInPort("input")
        self.output = {}
        self.output["MainApp"] = self.addOutPort()
        self.output["Field"] = self.addOutPort()
        self.output["Button"] = self.addOutPort()
        self.output["Ball"] = self.addOutPort()
    
    def extTransition(self, inputs):
        all_inputs = inputs[self.input]
        for input in all_inputs:
            self.State.to_send.append(input)
        return self.state
    
    def intTransition(self):
        self.State.to_send = []
        return self.State
    
    def outputFnc(self):
        out_dict = {}
        for (source, target, id, message) in self.State.to_send:
            out_dict[self.output[target]] = [(source, target, id, message)]
        return out_dict
    
    def timeAdvance(self):
        if self.State.to_send:
            return 0
        return INFINITY

class Controller(CoupledDEVS):
    def __init__(self, name):
        CoupledDEVS.__init__(self, name)
        self.ui = self.addInPort("ui")
        self.objectmanager = self.addSubModel(ObjectManager("ObjectManager"))
        self.atomic0 = self.addSubModel(MainApp("MainApp"))
        self.atomic1 = self.addSubModel(Field("Field"))
        self.atomic2 = self.addSubModel(Button("Button"))
        self.atomic3 = self.addSubModel(Ball("Ball"))
        self.connectPorts(self.atomic0.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["MainApp"], self.atomic0.obj_manager_in)
        self.connectPorts(self.atomic0.outputs["fields"], self.atomic1.input)
        self.connectPorts(self.atomic1.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Field"], self.atomic1.obj_manager_in)
        self.connectPorts(self.atomic1.outputs["balls"], self.atomic3.input)
        self.connectPorts(self.atomic1.outputs["buttons"], self.atomic2.input)
        self.connectPorts(self.atomic1.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic2.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Button"], self.atomic2.obj_manager_in)
        self.connectPorts(self.atomic2.outputs["parent"], self.atomic1.input)
        self.connectPorts(self.atomic3.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Ball"], self.atomic3.obj_manager_in)
        self.connectPorts(self.atomic3.outputs["parent"], self.atomic1.input)