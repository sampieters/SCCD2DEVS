"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration)

Model author: Sam Pieters
Model name:   Elevator Balls

"""

from sccd.runtime.statecharts_core import *
import sccd.runtime.libs.ui_v2 as ui
import random
import time

CANVAS_DIMS = (800, 550)
FLOOR_LENGTH = 350
FLOOR_SPACE = 50
FLOORS = 3

# package "Elevator Balls"

class MainApp(RuntimeClassBase):
    def __init__(self, controller):
        RuntimeClassBase.__init__(self, controller)
        
        self.inports["field_ui"] = controller.addInputPort("field_ui", self)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.num_floors = None
        self.floor_dimensions = None
        
        # call user defined constructor
        MainApp.user_defined_constructor(self)
    
    def user_defined_constructor(self):
        self.num_floors = 0
        self.button_num = FLOORS
        
        self.next_elevator_pos = None
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_window
        self.states["/creating_window"] = State(1, "/creating_window", self)
        self.states["/creating_window"].setEnter(self._creating_window_enter)
        
        # state /creating_canvas
        self.states["/creating_canvas"] = State(2, "/creating_canvas", self)
        self.states["/creating_canvas"].setEnter(self._creating_canvas_enter)
        
        # state /create_floors
        self.states["/create_floors"] = State(3, "/create_floors", self)
        
        # state /wait
        self.states["/wait"] = State(4, "/wait", self)
        
        # state /create_controls
        self.states["/create_controls"] = State(5, "/create_controls", self)
        
        # state /create_controls/create_buttons
        self.states["/create_controls/create_buttons"] = State(6, "/create_controls/create_buttons", self)
        
        # state /create_controls/create_buttons/create_a_button
        self.states["/create_controls/create_buttons/create_a_button"] = State(7, "/create_controls/create_buttons/create_a_button", self)
        self.states["/create_controls/create_buttons/create_a_button"].setEnter(self._create_controls_create_buttons_create_a_button_enter)
        
        # state /create_controls/create_buttons/start_a_button
        self.states["/create_controls/create_buttons/start_a_button"] = State(8, "/create_controls/create_buttons/start_a_button", self)
        
        # state /create_controls/create_buttons/check_next
        self.states["/create_controls/create_buttons/check_next"] = State(9, "/create_controls/create_buttons/check_next", self)
        
        # state /create_elevator
        self.states["/create_elevator"] = State(10, "/create_elevator", self)
        
        # state /creating
        self.states["/creating"] = State(11, "/creating", self)
        
        # state /running
        self.states["/running"] = State(12, "/running", self)
        
        # add children
        self.states[""].addChild(self.states["/creating_window"])
        self.states[""].addChild(self.states["/creating_canvas"])
        self.states[""].addChild(self.states["/create_floors"])
        self.states[""].addChild(self.states["/wait"])
        self.states[""].addChild(self.states["/create_controls"])
        self.states[""].addChild(self.states["/create_elevator"])
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/running"])
        self.states["/create_controls"].addChild(self.states["/create_controls/create_buttons"])
        self.states["/create_controls/create_buttons"].addChild(self.states["/create_controls/create_buttons/create_a_button"])
        self.states["/create_controls/create_buttons"].addChild(self.states["/create_controls/create_buttons/start_a_button"])
        self.states["/create_controls/create_buttons"].addChild(self.states["/create_controls/create_buttons/check_next"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_window"]
        self.states["/create_controls"].default_state = self.states["/create_controls/create_buttons"]
        self.states["/create_controls/create_buttons"].default_state = self.states["/create_controls/create_buttons/create_a_button"]
        
        # transition /creating_window
        _creating_window_0 = Transition(self, self.states["/creating_window"], [self.states["/creating_canvas"]])
        _creating_window_0.setAction(self._creating_window_0_exec)
        _creating_window_0.setTrigger(Event("window_created", None))
        self.states["/creating_window"].addTransition(_creating_window_0)
        
        # transition /creating_canvas
        _creating_canvas_0 = Transition(self, self.states["/creating_canvas"], [self.states["/create_floors"]])
        _creating_canvas_0.setAction(self._creating_canvas_0_exec)
        _creating_canvas_0.setTrigger(Event("canvas_created", None))
        self.states["/creating_canvas"].addTransition(_creating_canvas_0)
        
        # transition /create_floors
        _create_floors_0 = Transition(self, self.states["/create_floors"], [self.states["/create_controls"]])
        _create_floors_0.setTrigger(None)
        _create_floors_0.setGuard(self._create_floors_0_guard)
        self.states["/create_floors"].addTransition(_create_floors_0)
        _create_floors_1 = Transition(self, self.states["/create_floors"], [self.states["/wait"]])
        _create_floors_1.setAction(self._create_floors_1_exec)
        _create_floors_1.setTrigger(None)
        _create_floors_1.setGuard(self._create_floors_1_guard)
        self.states["/create_floors"].addTransition(_create_floors_1)
        
        # transition /wait
        _wait_0 = Transition(self, self.states["/wait"], [self.states["/wait"]])
        _wait_0.setAction(self._wait_0_exec)
        _wait_0.setTrigger(Event("instance_created", None))
        self.states["/wait"].addTransition(_wait_0)
        _wait_1 = Transition(self, self.states["/wait"], [self.states["/create_floors"]])
        _wait_1.setTrigger(Event("instance_started", None))
        self.states["/wait"].addTransition(_wait_1)
        
        # transition /create_controls/create_buttons/create_a_button
        _create_controls_create_buttons_create_a_button_0 = Transition(self, self.states["/create_controls/create_buttons/create_a_button"], [self.states["/create_controls/create_buttons/start_a_button"]])
        _create_controls_create_buttons_create_a_button_0.setAction(self._create_controls_create_buttons_create_a_button_0_exec)
        _create_controls_create_buttons_create_a_button_0.setTrigger(Event("instance_created", None))
        self.states["/create_controls/create_buttons/create_a_button"].addTransition(_create_controls_create_buttons_create_a_button_0)
        
        # transition /create_controls/create_buttons/start_a_button
        _create_controls_create_buttons_start_a_button_0 = Transition(self, self.states["/create_controls/create_buttons/start_a_button"], [self.states["/create_controls/create_buttons/check_next"]])
        _create_controls_create_buttons_start_a_button_0.setTrigger(Event("instance_started", None))
        self.states["/create_controls/create_buttons/start_a_button"].addTransition(_create_controls_create_buttons_start_a_button_0)
        
        # transition /create_controls/create_buttons/check_next
        _create_controls_create_buttons_check_next_0 = Transition(self, self.states["/create_controls/create_buttons/check_next"], [self.states["/create_controls/create_buttons/create_a_button"]])
        _create_controls_create_buttons_check_next_0.setAction(self._create_controls_create_buttons_check_next_0_exec)
        _create_controls_create_buttons_check_next_0.setTrigger(None)
        _create_controls_create_buttons_check_next_0.setGuard(self._create_controls_create_buttons_check_next_0_guard)
        self.states["/create_controls/create_buttons/check_next"].addTransition(_create_controls_create_buttons_check_next_0)
        _create_controls_create_buttons_check_next_1 = Transition(self, self.states["/create_controls/create_buttons/check_next"], [self.states["/create_elevator"]])
        _create_controls_create_buttons_check_next_1.setTrigger(None)
        _create_controls_create_buttons_check_next_1.setGuard(self._create_controls_create_buttons_check_next_1_guard)
        self.states["/create_controls/create_buttons/check_next"].addTransition(_create_controls_create_buttons_check_next_1)
        
        # transition /create_elevator
        _create_elevator_0 = Transition(self, self.states["/create_elevator"], [self.states["/creating"]])
        _create_elevator_0.setAction(self._create_elevator_0_exec)
        _create_elevator_0.setTrigger(None)
        self.states["/create_elevator"].addTransition(_create_elevator_0)
        
        # transition /creating
        _creating_0 = Transition(self, self.states["/creating"], [self.states["/running"]])
        _creating_0.setAction(self._creating_0_exec)
        _creating_0.setTrigger(Event("instance_created", None))
        self.states["/creating"].addTransition(_creating_0)
        
        # transition /running
        _running_0 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_0.setAction(self._running_0_exec)
        _running_0.setTrigger(Event("create_ball", None))
        self.states["/running"].addTransition(_running_0)
        _running_1 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_1.setAction(self._running_1_exec)
        _running_1.setTrigger(Event("instance_created", None))
        self.states["/running"].addTransition(_running_1)
        _running_2 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_2.setAction(self._running_2_exec)
        _running_2.setTrigger(Event("update_bounds", None))
        self.states["/running"].addTransition(_running_2)
        _running_3 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_3.setAction(self._running_3_exec)
        _running_3.setTrigger(Event("button_pressed", None))
        self.states["/running"].addTransition(_running_3)
        _running_4 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_4.setAction(self._running_4_exec)
        _running_4.setTrigger(Event("open_elevator", None))
        self.states["/running"].addTransition(_running_4)
    
    def _creating_window_enter(self):
        self.big_step.outputEvent(Event("create_window", self.getOutPortName("ui"), [CANVAS_DIMS[0], CANVAS_DIMS[1], "Bouncing Balls Elevator", self.inports['field_ui']]))
    
    def _creating_canvas_enter(self):
        self.big_step.outputEvent(Event("create_canvas", self.getOutPortName("ui"), [self.window_id, CANVAS_DIMS[0], CANVAS_DIMS[1] - 150, {'background':'#fff'}, self.inports['field_ui']]))
    
    def _create_controls_create_buttons_create_a_button_enter(self):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "button", "ElevatorButton", self.window_id, self.canvas_id, self.button_num - 1]))
    
    def _creating_window_0_exec(self, parameters):
        window_id = parameters[0]
        self.window_id = window_id
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.WINDOW_CLOSE, 'window_close', self.inports['field_ui']]))
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.KEY_PRESS, 'key_press', self.inports['field_ui']]))
    
    def _creating_canvas_0_exec(self, parameters):
        canvas_id = parameters[0]
        self.canvas_id = canvas_id
    
    def _create_floors_0_guard(self, parameters):
        return self.num_floors == FLOORS
    
    def _create_floors_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "floor", "Floor", self.canvas_id, self.num_floors]))
        self.num_floors += 1
    
    def _create_floors_1_guard(self, parameters):
        return self.num_floors != FLOORS
    
    def _wait_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _create_controls_create_buttons_create_a_button_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _create_controls_create_buttons_check_next_0_exec(self, parameters):
        self.button_num -= 1
    
    def _create_controls_create_buttons_check_next_0_guard(self, parameters):
        return self.button_num != 1
    
    def _create_controls_create_buttons_check_next_1_guard(self, parameters):
        return self.button_num == 1
    
    def _create_elevator_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "elevator", "Elevator", self.canvas_id]))
    
    def _creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name, self.canvas_id, self.window_id])]))
    
    def _running_0_exec(self, parameters):
        floor_num = parameters[0]
        x = parameters[1]
        y = parameters[2]
        self.big_step.outputEventOM(Event("create_instance", None, [self, "ball", "Ball", self.canvas_id, floor_num, x, y]))
    
    def _running_1_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
    
    def _running_2_exec(self, parameters):
        pos = parameters[0]
        dim = parameters[1]
        vel = parameters[2]
        self.big_step.outputEventOM(Event("broad_cast", None, [self, Event("update_bounds", None, [pos, dim, vel])]))
    
    def _running_3_exec(self, parameters):
        floor_number = parameters[0]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'elevator', Event("move_elevator", None, [floor_number])]))
    
    def _running_4_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'ball', Event("open_elevator", None, [])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_window"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Floor(RuntimeClassBase):
    def __init__(self, controller, canvas_id, floor_num):
        RuntimeClassBase.__init__(self, controller)
        
        self.inports["floor_ui"] = controller.addInputPort("floor_ui", self)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        Floor.user_defined_constructor(self, canvas_id, floor_num)
    
    def user_defined_constructor(self, canvas_id, floor_num):
        self.canvas_id = canvas_id;
        self.floor_num = floor_num;
        
        height = CANVAS_DIMS[1] - 150
        
        y_dim = (height - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': FLOOR_LENGTH, 'y': y_dim};
        
        
        # start position from the bottom instead of from the top
        # self.pos = {'x': FLOOR_LENGTH / 2, 'y': (y_dim /2) + (self.floor_num * (y_dim + FLOOR_SPACE))};
        
        self.pos = {'x': FLOOR_LENGTH / 2, 'y': height - (y_dim /2) - ( self.floor_num * (y_dim + FLOOR_SPACE)  )};
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_floor
        self.states["/creating_floor"] = State(1, "/creating_floor", self)
        self.states["/creating_floor"].setEnter(self._creating_floor_enter)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # state /running/create_random_ball
        self.states["/running/create_random_ball"] = State(3, "/running/create_random_ball", self)
        self.states["/running/create_random_ball"].setEnter(self._running_create_random_ball_enter)
        self.states["/running/create_random_ball"].setExit(self._running_create_random_ball_exit)
        
        # add children
        self.states[""].addChild(self.states["/creating_floor"])
        self.states[""].addChild(self.states["/running"])
        self.states["/running"].addChild(self.states["/running/create_random_ball"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_floor"]
        self.states["/running"].default_state = self.states["/running/create_random_ball"]
        
        # transition /creating_floor
        _creating_floor_0 = Transition(self, self.states["/creating_floor"], [self.states["/running"]])
        _creating_floor_0.setTrigger(Event("rectangle_created", None))
        self.states["/creating_floor"].addTransition(_creating_floor_0)
        
        # transition /running/create_random_ball
        _running_create_random_ball_0 = Transition(self, self.states["/running/create_random_ball"], [self.states["/running/create_random_ball"]])
        _running_create_random_ball_0.setAction(self._running_create_random_ball_0_exec)
        _running_create_random_ball_0.setTrigger(Event("_0after"))
        self.states["/running/create_random_ball"].addTransition(_running_create_random_ball_0)
    
    def _creating_floor_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['floor_ui']]))
    
    def _running_create_random_ball_enter(self):
        self.addTimer(0, random.randint(2, 10))
    
    def _running_create_random_ball_exit(self):
        self.removeTimer(0)
    
    def _running_create_random_ball_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("create_ball", None, [self.floor_num, 10, self.pos['y']])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_floor"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class ElevatorButton(RuntimeClassBase):
    def __init__(self, controller, window_id, canvas_id, number):
        RuntimeClassBase.__init__(self, controller)
        
        self.inports["button_ui"] = controller.addInputPort("button_ui", self)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        ElevatorButton.user_defined_constructor(self, window_id, canvas_id, number)
    
    def user_defined_constructor(self, window_id, canvas_id, number):
        self.window_id = window_id;
        self.canvas_id = canvas_id;
        self.button_id = None;
        
        self.dim = {'x': 120, 'y': (50 + (FLOORS * 30))}
        self.pos = {'x': CANVAS_DIMS[0] - ((self.dim['x'] / 2) + 10), 'y': (self.dim['y'] / 2) + 10}
        self.r = 10
        self.number = number;
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating
        self.states["/creating"] = State(1, "/creating", self)
        self.states["/creating"].setEnter(self._creating_enter)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # add children
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/running"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating"]
        
        # transition /creating
        _creating_0 = Transition(self, self.states["/creating"], [self.states["/running"]])
        _creating_0.setAction(self._creating_0_exec)
        _creating_0.setTrigger(Event("button_created", None))
        self.states["/creating"].addTransition(_creating_0)
        
        # transition /running
        _running_0 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_0.setAction(self._running_0_exec)
        _running_0.setTrigger(Event("mouse_click", self.getInPortName("button_ui")))
        _running_0.setGuard(self._running_0_guard)
        self.states["/running"].addTransition(_running_0)
    
    def _creating_enter(self):
        self.big_step.outputEvent(Event("create_button", self.getOutPortName("ui"), [self.window_id, self.number, self.inports['button_ui']]))
    
    def _creating_0_exec(self, parameters):
        button_id = parameters[0]
        self.button_id = button_id
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [button_id, ui.EVENTS.MOUSE_CLICK, "mouse_click", self.inports['button_ui']]))
    
    def _running_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("button_pressed", None, [self.number])]))
    
    def _running_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Elevator(RuntimeClassBase):
    def __init__(self, controller, canvas_id):
        RuntimeClassBase.__init__(self, controller)
        
        self.inports["elevator_ui"] = controller.addInputPort("elevator_ui", self)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        Elevator.user_defined_constructor(self, canvas_id)
    
    def user_defined_constructor(self, canvas_id):
        self.canvas_id = canvas_id;
        
        height = CANVAS_DIMS[1] - 150
        
        elevator_height = (height - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': elevator_height, 'y': elevator_height};
        self.vel = -2;
        
        self.current_floor = 0;
        
        self.pos = {'x': FLOOR_LENGTH + (elevator_height / 2), 'y': (height - (elevator_height / 2))};
        self.next_pos = {'x': FLOOR_LENGTH / 2, 'y': None};
        
        
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /root
        self.states["/root"] = State(1, "/root", self)
        
        # state /root/waiting
        self.states["/root/waiting"] = State(2, "/root/waiting", self)
        
        # state /root/creating_elevator
        self.states["/root/creating_elevator"] = State(3, "/root/creating_elevator", self)
        self.states["/root/creating_elevator"].setEnter(self._root_creating_elevator_enter)
        
        # state /root/running
        self.states["/root/running"] = State(4, "/root/running", self)
        
        # state /root/running/idle
        self.states["/root/running/idle"] = State(5, "/root/running/idle", self)
        self.states["/root/running/idle"].setEnter(self._root_running_idle_enter)
        
        # state /root/running/move
        self.states["/root/running/move"] = State(6, "/root/running/move", self)
        self.states["/root/running/move"].setEnter(self._root_running_move_enter)
        self.states["/root/running/move"].setExit(self._root_running_move_exit)
        
        # add children
        self.states[""].addChild(self.states["/root"])
        self.states["/root"].addChild(self.states["/root/waiting"])
        self.states["/root"].addChild(self.states["/root/creating_elevator"])
        self.states["/root"].addChild(self.states["/root/running"])
        self.states["/root/running"].addChild(self.states["/root/running/idle"])
        self.states["/root/running"].addChild(self.states["/root/running/move"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/root"]
        self.states["/root"].default_state = self.states["/root/waiting"]
        self.states["/root/running"].default_state = self.states["/root/running/idle"]
        
        # transition /root/waiting
        _root_waiting_0 = Transition(self, self.states["/root/waiting"], [self.states["/root/creating_elevator"]])
        _root_waiting_0.setAction(self._root_waiting_0_exec)
        _root_waiting_0.setTrigger(Event("set_association_name", None))
        self.states["/root/waiting"].addTransition(_root_waiting_0)
        
        # transition /root/creating_elevator
        _root_creating_elevator_0 = Transition(self, self.states["/root/creating_elevator"], [self.states["/root/running"]])
        _root_creating_elevator_0.setAction(self._root_creating_elevator_0_exec)
        _root_creating_elevator_0.setTrigger(Event("rectangle_created", None))
        self.states["/root/creating_elevator"].addTransition(_root_creating_elevator_0)
        
        # transition /root/running/idle
        _root_running_idle_0 = Transition(self, self.states["/root/running/idle"], [self.states["/root/running/move"]])
        _root_running_idle_0.setAction(self._root_running_idle_0_exec)
        _root_running_idle_0.setTrigger(Event("move_elevator", None))
        self.states["/root/running/idle"].addTransition(_root_running_idle_0)
        
        # transition /root/running/move
        _root_running_move_0 = Transition(self, self.states["/root/running/move"], [self.states["/root/running/move"]])
        _root_running_move_0.setAction(self._root_running_move_0_exec)
        _root_running_move_0.setTrigger(Event("_0after"))
        self.states["/root/running/move"].addTransition(_root_running_move_0)
        _root_running_move_1 = Transition(self, self.states["/root/running/move"], [self.states["/root/running/idle"]])
        _root_running_move_1.setAction(self._root_running_move_1_exec)
        _root_running_move_1.setTrigger(None)
        _root_running_move_1.setGuard(self._root_running_move_1_guard)
        self.states["/root/running/move"].addTransition(_root_running_move_1)
    
    def _root_creating_elevator_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['elevator_ui']]))
    
    def _root_running_idle_enter(self):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("update_bounds", None, [self.pos, self.dim, self.vel])]))
    
    def _root_running_move_enter(self):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("update_bounds", None, [self.pos, self.dim, self.vel])]))
        self.addTimer(0, 0.02)
    
    def _root_running_move_exit(self):
        self.removeTimer(0)
    
    def _root_waiting_0_exec(self, parameters):
        association_name = parameters[0]
        canvas_id = parameters[1]
        window_id = parameters[2]
        self.association_name = association_name
        self.canvas_id = canvas_id
        self.window_id = window_id
    
    def _root_creating_elevator_0_exec(self, parameters):
        canvas_id = parameters[0]
        rect_id = parameters[1]
        self.elevator_id = rect_id
    
    def _root_running_idle_0_exec(self, parameters):
        floor_number = parameters[0]
        if self.current_floor < floor_number:
            self.vel = -2
        else:
            self.vel = 2
        
        height = (CANVAS_DIMS[1] - 150)
        y_dim = (height - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        self.next_pos['y'] = height - (y_dim /2) - (floor_number * (y_dim + FLOOR_SPACE));
    
    def _root_running_move_0_exec(self, parameters):
        self.big_step.outputEvent(Event("set_element_pos", self.getOutPortName("ui"), [self.canvas_id, self.elevator_id, self.pos['x'], self.pos['y']]))
        self.pos['y'] += self.vel
    
    def _root_running_move_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("open_elevator", None, [])]))
    
    def _root_running_move_1_guard(self, parameters):
        return (self.pos['y']) < self.next_pos['y']
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/root"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Ball(RuntimeClassBase):
    def __init__(self, controller, canvas_id, floor_num, x, y):
        RuntimeClassBase.__init__(self, controller)
        
        self.inports["ball_ui"] = controller.addInputPort("ball_ui", self)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.canvas_id = None
        self.pos = None
        
        # call user defined constructor
        Ball.user_defined_constructor(self, canvas_id, floor_num, x, y)
    
    def user_defined_constructor(self, canvas_id, floor_num, x, y):
        self.canvas_id = canvas_id;
        
        
        self.floor_num = floor_num;
        
        self.elevator_floor = 0;
        self.elevator_open = True;
        self.rect_pos = None;
        self.rect_dim = None;
        
        self.r = 5.0;
        self.vel = {'x': random.uniform(-5.0, 5.0), 'y': random.uniform(-5.0, 5.0)};
        self.pos = {'x': x, 'y': y};
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /main_behaviour
        self.states["/main_behaviour"] = State(1, "/main_behaviour", self)
        
        # state /main_behaviour/initializing
        self.states["/main_behaviour/initializing"] = State(2, "/main_behaviour/initializing", self)
        
        # state /main_behaviour/creating_circle
        self.states["/main_behaviour/creating_circle"] = State(3, "/main_behaviour/creating_circle", self)
        self.states["/main_behaviour/creating_circle"].setEnter(self._main_behaviour_creating_circle_enter)
        
        # state /main_behaviour/bouncing
        self.states["/main_behaviour/bouncing"] = State(4, "/main_behaviour/bouncing", self)
        self.states["/main_behaviour/bouncing"].setEnter(self._main_behaviour_bouncing_enter)
        self.states["/main_behaviour/bouncing"].setExit(self._main_behaviour_bouncing_exit)
        
        # state /main_behaviour/ball_delete
        self.states["/main_behaviour/ball_delete"] = State(5, "/main_behaviour/ball_delete", self)
        
        # state /deleted
        self.states["/deleted"] = State(6, "/deleted", self)
        
        # add children
        self.states[""].addChild(self.states["/main_behaviour"])
        self.states[""].addChild(self.states["/deleted"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/initializing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/creating_circle"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/bouncing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/ball_delete"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/main_behaviour"]
        self.states["/main_behaviour"].default_state = self.states["/main_behaviour/initializing"]
        
        # transition /main_behaviour/initializing
        _main_behaviour_initializing_0 = Transition(self, self.states["/main_behaviour/initializing"], [self.states["/main_behaviour/creating_circle"]])
        _main_behaviour_initializing_0.setAction(self._main_behaviour_initializing_0_exec)
        _main_behaviour_initializing_0.setTrigger(Event("set_association_name", None))
        self.states["/main_behaviour/initializing"].addTransition(_main_behaviour_initializing_0)
        
        # transition /main_behaviour/creating_circle
        _main_behaviour_creating_circle_0 = Transition(self, self.states["/main_behaviour/creating_circle"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_creating_circle_0.setAction(self._main_behaviour_creating_circle_0_exec)
        _main_behaviour_creating_circle_0.setTrigger(Event("circle_created", None))
        self.states["/main_behaviour/creating_circle"].addTransition(_main_behaviour_creating_circle_0)
        
        # transition /main_behaviour/bouncing
        _main_behaviour_bouncing_0 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_0.setAction(self._main_behaviour_bouncing_0_exec)
        _main_behaviour_bouncing_0.setTrigger(Event("_0after"))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_0)
        _main_behaviour_bouncing_1 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_1.setAction(self._main_behaviour_bouncing_1_exec)
        _main_behaviour_bouncing_1.setTrigger(Event("open_elevator", None))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_1)
        _main_behaviour_bouncing_2 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/ball_delete"]])
        _main_behaviour_bouncing_2.setTrigger(None)
        _main_behaviour_bouncing_2.setGuard(self._main_behaviour_bouncing_2_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_2)
        _main_behaviour_bouncing_3 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_3.setAction(self._main_behaviour_bouncing_3_exec)
        _main_behaviour_bouncing_3.setTrigger(Event("update_bounds", None))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_3)
        
        # transition /main_behaviour/ball_delete
        _main_behaviour_ball_delete_0 = Transition(self, self.states["/main_behaviour/ball_delete"], [self.states["/deleted"]])
        _main_behaviour_ball_delete_0.setAction(self._main_behaviour_ball_delete_0_exec)
        _main_behaviour_ball_delete_0.setTrigger(Event("delete_self", None))
        self.states["/main_behaviour/ball_delete"].addTransition(_main_behaviour_ball_delete_0)
    
    def _main_behaviour_creating_circle_enter(self):
        self.big_step.outputEvent(Event("create_circle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.r, {'fill':'#000'}, self.inports['ball_ui']]))
    
    def _main_behaviour_bouncing_enter(self):
        self.addTimer(0, 0.02)
    
    def _main_behaviour_bouncing_exit(self):
        self.removeTimer(0)
    
    def _main_behaviour_initializing_0_exec(self, parameters):
        association_name = parameters[0]
        self.association_name = association_name
    
    def _main_behaviour_creating_circle_0_exec(self, parameters):
        canvas_id = parameters[0]
        circle_id = parameters[1]
        self.circle_id = circle_id
    
    def _main_behaviour_bouncing_0_exec(self, parameters):
        if self.floor_num == -1:
            if self.pos['x'] - self.r < self.rect_pos['x'] - (self.rect_dim['x'] / 2):
                if self.elevator_open:
                    self.floor_num = self.elevator_floor
                else:
                    self.pos['x'] = self.rect_pos['x'] - (self.rect_dim['x'] / 2) + self.r
                    self.vel['x'] = -self.vel['x']
            elif self.pos['x'] + self.r > self.rect_pos['x'] + (self.rect_dim['x'] / 2):
                self.pos['x'] = self.rect_pos['x'] + (self.rect_dim['x'] / 2) - self.r
                self.vel['x'] = -self.vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < self.rect_pos['y'] - (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] - (self.rect_dim['y'] / 2) + self.r
                self.vel['y'] = -self.vel['y'] + self.rect_vel
            elif self.pos['y'] + self.r > self.rect_pos['y'] + (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] + (self.rect_dim['y'] / 2) - self.r
                self.vel['y'] = -self.vel['y'] + self.rect_vel
        else:
            floor_height = ((CANVAS_DIMS[1] - 150) - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
            floor_dim = {'x': FLOOR_LENGTH, 'y': floor_height};
            floor_pos = {'x': FLOOR_LENGTH / 2, 'y': (CANVAS_DIMS[1] - 150) - (floor_height /2) - ( self.floor_num * (floor_height + FLOOR_SPACE)  )};
        
            if self.pos['x'] - self.r < floor_pos['x'] - (floor_dim['x'] / 2):
                self.pos['x'] = floor_pos['x'] - (floor_dim['x'] / 2) + self.r
                self.vel['x'] = -self.vel['x']
            elif self.pos['x'] + self.r > floor_pos['x'] + (floor_dim['x'] / 2):
                if self.elevator_open and (self.elevator_floor == self.floor_num):
                    self.floor_num = -1
                else:
                    self.pos['x'] = floor_pos['x'] + (floor_dim['x'] / 2) - self.r
                    self.vel['x'] = -self.vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < floor_pos['y'] - (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] - (floor_dim['y'] / 2) + self.r
                self.vel['y'] = -self.vel['y']
            elif self.pos['y'] + self.r > floor_pos['y'] + (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] + (floor_dim['y'] / 2) - self.r  # Correct position
                self.vel['y'] = -self.vel['y']
        self.big_step.outputEvent(Event("move_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, self.vel['x'], self.vel['y']]))
        self.pos['x'] += self.vel['x']
        self.pos['y'] += self.vel['y']
    
    def _main_behaviour_bouncing_1_exec(self, parameters):
        self.elevator_open = True
    
    def _main_behaviour_bouncing_2_guard(self, parameters):
        return self.pos['x'] - self.r < 2
    
    def _main_behaviour_bouncing_3_exec(self, parameters):
        pos = parameters[0]
        dim = parameters[1]
        vel = parameters[2]
        self.rect_pos = pos
        self.rect_dim = dim
        self.rect_vel = vel
        self.elevator_open = False
    
    def _main_behaviour_ball_delete_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'floor', Event("delete_ball", None, [self.association_name])]))
        self.big_step.outputEvent(Event("destroy_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/main_behaviour"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class ObjectManager(ObjectManagerBase):
    def __init__(self, controller):
        ObjectManagerBase.__init__(self, controller)
    
    def instantiate(self, class_name, construct_params):
        if class_name == "MainApp":
            instance = MainApp(self.controller)
            instance.associations = {}
            instance.associations["floor"] = Association("Floor", 2, -1)
            instance.associations["button"] = Association("ElevatorButton", 0, -1)
            instance.associations["elevator"] = Association("Elevator", 1, 1)
            instance.associations["ball"] = Association("Ball", 0, -1)
        elif class_name == "Floor":
            instance = Floor(self.controller, construct_params[0], construct_params[1])
            instance.associations = {}
            instance.associations["parent"] = Association("MainApp", 1, 1)
        elif class_name == "ElevatorButton":
            instance = ElevatorButton(self.controller, construct_params[0], construct_params[1], construct_params[2])
            instance.associations = {}
            instance.associations["parent"] = Association("MainApp", 1, 1)
        elif class_name == "Elevator":
            instance = Elevator(self.controller, construct_params[0])
            instance.associations = {}
            instance.associations["floors"] = Association("Floor", 1, 1)
            instance.associations["parent"] = Association("MainApp", 1, 1)
        elif class_name == "Ball":
            instance = Ball(self.controller, construct_params[0], construct_params[1], construct_params[2], construct_params[3])
            instance.associations = {}
            instance.associations["parent"] = Association("MainApp", 1, 1)
        else:
            raise Exception("Cannot instantiate class " + class_name)
        return instance

class Controller(EventLoopControllerBase):
    def __init__(self, event_loop_callbacks, finished_callback = None, behind_schedule_callback = None):
        if finished_callback == None: finished_callback = None
        if behind_schedule_callback == None: behind_schedule_callback = None
        EventLoopControllerBase.__init__(self, ObjectManager(self), event_loop_callbacks, finished_callback, behind_schedule_callback)
        self.addInputPort("ui")
        self.addOutputPort("ui")
        self.object_manager.createInstance("MainApp", [])