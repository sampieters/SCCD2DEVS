"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration) and Sam Pieters (DEVS)

Model author: Sam Pieters
Model name:   Elevator Balls

"""

from sccd.runtime.DEVS_statecharts_core import *
import sccd.runtime.libs.ui_v2 as ui
import random
import time

CANVAS_DIMS = (800, 550)
FLOOR_LENGTH = 350
FLOOR_SPACE = 50
FLOORS = 3

# package "Elevator Balls"

class MainAppInstance(RuntimeClassBase):
    def __init__(self, atomdevs):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["floor"] = Association("Floor", 2, -1)
        self.associations["controls"] = Association("ElevatorControls", 1, 1)
        self.associations["elevator"] = Association("Elevator", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.num_floors = None
        self.floor_dimensions = None
        
        # call user defined constructor
        MainAppInstance.user_defined_constructor(self)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("field_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["field_ui"] = port_name
    
    def user_defined_constructor(self):
        self.num_floors = 0
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_window
        self.states["/creating_window"] = State(1, "/creating_window", self)
        self.states["/creating_window"].setEnter(self._creating_window_enter)
        
        # state /creating_canvas
        self.states["/creating_canvas"] = State(2, "/creating_canvas", self)
        self.states["/creating_canvas"].setEnter(self._creating_canvas_enter)
        
        # state /create_floors
        self.states["/create_floors"] = State(3, "/create_floors", self)
        
        # state /wait
        self.states["/wait"] = State(4, "/wait", self)
        
        # state /create_controls
        self.states["/create_controls"] = State(5, "/create_controls", self)
        
        # state /creating_controls
        self.states["/creating_controls"] = State(6, "/creating_controls", self)
        
        # state /create_elevator
        self.states["/create_elevator"] = State(7, "/create_elevator", self)
        
        # state /creating
        self.states["/creating"] = State(8, "/creating", self)
        
        # state /waiting
        self.states["/waiting"] = State(9, "/waiting", self)
        
        # add children
        self.states[""].addChild(self.states["/creating_window"])
        self.states[""].addChild(self.states["/creating_canvas"])
        self.states[""].addChild(self.states["/create_floors"])
        self.states[""].addChild(self.states["/wait"])
        self.states[""].addChild(self.states["/create_controls"])
        self.states[""].addChild(self.states["/creating_controls"])
        self.states[""].addChild(self.states["/create_elevator"])
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/waiting"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_window"]
        
        # transition /creating_window
        _creating_window_0 = Transition(self, self.states["/creating_window"], [self.states["/creating_canvas"]])
        _creating_window_0.setAction(self._creating_window_0_exec)
        _creating_window_0.setTrigger(Event("window_created", None))
        self.states["/creating_window"].addTransition(_creating_window_0)
        
        # transition /creating_canvas
        _creating_canvas_0 = Transition(self, self.states["/creating_canvas"], [self.states["/create_floors"]])
        _creating_canvas_0.setAction(self._creating_canvas_0_exec)
        _creating_canvas_0.setTrigger(Event("canvas_created", None))
        self.states["/creating_canvas"].addTransition(_creating_canvas_0)
        
        # transition /create_floors
        _create_floors_0 = Transition(self, self.states["/create_floors"], [self.states["/create_controls"]])
        _create_floors_0.setTrigger(None)
        _create_floors_0.setGuard(self._create_floors_0_guard)
        self.states["/create_floors"].addTransition(_create_floors_0)
        _create_floors_1 = Transition(self, self.states["/create_floors"], [self.states["/wait"]])
        _create_floors_1.setAction(self._create_floors_1_exec)
        _create_floors_1.setTrigger(None)
        _create_floors_1.setGuard(self._create_floors_1_guard)
        self.states["/create_floors"].addTransition(_create_floors_1)
        
        # transition /wait
        _wait_0 = Transition(self, self.states["/wait"], [self.states["/wait"]])
        _wait_0.setAction(self._wait_0_exec)
        _wait_0.setTrigger(Event("instance_created", None))
        self.states["/wait"].addTransition(_wait_0)
        _wait_1 = Transition(self, self.states["/wait"], [self.states["/create_floors"]])
        _wait_1.setTrigger(Event("instance_started", None))
        self.states["/wait"].addTransition(_wait_1)
        
        # transition /create_controls
        _create_controls_0 = Transition(self, self.states["/create_controls"], [self.states["/creating_controls"]])
        _create_controls_0.setAction(self._create_controls_0_exec)
        _create_controls_0.setTrigger(None)
        self.states["/create_controls"].addTransition(_create_controls_0)
        
        # transition /creating_controls
        _creating_controls_0 = Transition(self, self.states["/creating_controls"], [self.states["/create_elevator"]])
        _creating_controls_0.setAction(self._creating_controls_0_exec)
        _creating_controls_0.setTrigger(Event("instance_created", None))
        self.states["/creating_controls"].addTransition(_creating_controls_0)
        
        # transition /create_elevator
        _create_elevator_0 = Transition(self, self.states["/create_elevator"], [self.states["/creating"]])
        _create_elevator_0.setAction(self._create_elevator_0_exec)
        _create_elevator_0.setTrigger(None)
        self.states["/create_elevator"].addTransition(_create_elevator_0)
        
        # transition /creating
        _creating_0 = Transition(self, self.states["/creating"], [self.states["/waiting"]])
        _creating_0.setAction(self._creating_0_exec)
        _creating_0.setTrigger(Event("instance_created", None))
        self.states["/creating"].addTransition(_creating_0)
    
    def _creating_window_enter(self):
        self.big_step.outputEvent(Event("create_window", self.getOutPortName("ui"), [CANVAS_DIMS[0], CANVAS_DIMS[1], "Bouncing Balls Elevator", self.inports['field_ui']]))
    
    def _creating_canvas_enter(self):
        self.big_step.outputEvent(Event("create_canvas", self.getOutPortName("ui"), [self.window_id, CANVAS_DIMS[0], CANVAS_DIMS[1] - 200, {'background':'#fff'}, self.inports['field_ui']]))
    
    def _creating_window_0_exec(self, parameters):
        window_id = parameters[0]
        self.window_id = window_id
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.WINDOW_CLOSE, 'window_close', self.inports['field_ui']]))
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.KEY_PRESS, 'key_press', self.inports['field_ui']]))
    
    def _creating_canvas_0_exec(self, parameters):
        canvas_id = parameters[0]
        self.canvas_id = canvas_id
    
    def _create_floors_0_guard(self, parameters):
        return self.num_floors == FLOORS
    
    def _create_floors_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "floor", "Floor", self.canvas_id, self.num_floors]))
        self.num_floors += 1
    
    def _create_floors_1_guard(self, parameters):
        return self.num_floors != FLOORS
    
    def _wait_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _create_controls_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "controls", "ElevatorControls", self.canvas_id]))
    
    def _creating_controls_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _create_elevator_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "elevator", "Elevator", self.canvas_id]))
    
    def _creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name, self.canvas_id, self.window_id])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_window"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class MainApp(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["floor"] = self.addOutPort("floor")
        self.outputs["controls"] = self.addOutPort("controls")
        self.outputs["elevator"] = self.addOutPort("elevator")
        self.field_ui = self.addInPort("field_ui")
        self.instances[self.next_instance] = MainAppInstance(self)
        self.next_instance = self.next_instance + 1
    
    def constructObject(self, parameters):
        new_instance = MainAppInstance(self)
        return new_instance

class FloorInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id, floor_num):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        FloorInstance.user_defined_constructor(self, canvas_id, floor_num)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("floor_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["floor_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id, floor_num):
        self.canvas_id = canvas_id;
        self.floor_num = floor_num;
        
        y_dim = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': FLOOR_LENGTH, 'y': y_dim};
        self.pos = {'x': FLOOR_LENGTH / 2, 'y': (y_dim /2) + (self.floor_num * (y_dim + FLOOR_SPACE))};
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_floor
        self.states["/creating_floor"] = State(1, "/creating_floor", self)
        self.states["/creating_floor"].setEnter(self._creating_floor_enter)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # state /running/create_random_ball
        self.states["/running/create_random_ball"] = State(3, "/running/create_random_ball", self)
        self.states["/running/create_random_ball"].setEnter(self._running_create_random_ball_enter)
        self.states["/running/create_random_ball"].setExit(self._running_create_random_ball_exit)
        
        # state /running/wait
        self.states["/running/wait"] = State(4, "/running/wait", self)
        
        # add children
        self.states[""].addChild(self.states["/creating_floor"])
        self.states[""].addChild(self.states["/running"])
        self.states["/running"].addChild(self.states["/running/create_random_ball"])
        self.states["/running"].addChild(self.states["/running/wait"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_floor"]
        self.states["/running"].default_state = self.states["/running/create_random_ball"]
        
        # transition /creating_floor
        _creating_floor_0 = Transition(self, self.states["/creating_floor"], [self.states["/running"]])
        _creating_floor_0.setTrigger(Event("rectangle_created", None))
        self.states["/creating_floor"].addTransition(_creating_floor_0)
        
        # transition /running/create_random_ball
        _running_create_random_ball_0 = Transition(self, self.states["/running/create_random_ball"], [self.states["/running/wait"]])
        _running_create_random_ball_0.setAction(self._running_create_random_ball_0_exec)
        _running_create_random_ball_0.setTrigger(Event("_0after"))
        self.states["/running/create_random_ball"].addTransition(_running_create_random_ball_0)
        
        # transition /running/wait
        _running_wait_0 = Transition(self, self.states["/running/wait"], [self.states["/running/create_random_ball"]])
        _running_wait_0.setAction(self._running_wait_0_exec)
        _running_wait_0.setTrigger(Event("instance_created", None))
        self.states["/running/wait"].addTransition(_running_wait_0)
    
    def _creating_floor_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['floor_ui']]))
    
    def _running_create_random_ball_enter(self):
        self.addTimer(0, random.randint(2, 10))
    
    def _running_create_random_ball_exit(self):
        self.removeTimer(0)
    
    def _running_create_random_ball_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "balls", "Ball", self.canvas_id, self.floor_num, 10, self.pos['y']]))
    
    def _running_wait_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_floor"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Floor(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["parent"] = self.addOutPort("parent")
        self.floor_ui = self.addInPort("floor_ui")
    
    def constructObject(self, parameters):
        new_instance = FloorInstance(self, parameters[2], parameters[3])
        return new_instance

class ElevatorControlsInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["button"] = Association("ElevatorButton", 0, -1)
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["parent"] = Association("Elevator", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        ElevatorControlsInstance.user_defined_constructor(self, canvas_id)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("control_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["control_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id):
        self.canvas_id = canvas_id;
        self.button_num = FLOORS;
        self.dim = {'x': 120, 'y': (50 + (FLOORS * 30))}
        self.pos = {'x': CANVAS_DIMS[0] - ((self.dim['x'] / 2) + 10), 'y': (self.dim['y'] / 2) + 10}
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating
        self.states["/creating"] = State(1, "/creating", self)
        
        # state /creating/create_rect
        self.states["/creating/create_rect"] = State(2, "/creating/create_rect", self)
        self.states["/creating/create_rect"].setEnter(self._creating_create_rect_enter)
        
        # state /creating/create_buttons
        self.states["/creating/create_buttons"] = State(3, "/creating/create_buttons", self)
        
        # state /creating/create_buttons/create_a_button
        self.states["/creating/create_buttons/create_a_button"] = State(4, "/creating/create_buttons/create_a_button", self)
        self.states["/creating/create_buttons/create_a_button"].setEnter(self._creating_create_buttons_create_a_button_enter)
        
        # state /creating/create_buttons/start_a_button
        self.states["/creating/create_buttons/start_a_button"] = State(5, "/creating/create_buttons/start_a_button", self)
        
        # state /creating/create_buttons/check_next
        self.states["/creating/create_buttons/check_next"] = State(6, "/creating/create_buttons/check_next", self)
        
        # state /running
        self.states["/running"] = State(7, "/running", self)
        
        # add children
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/running"])
        self.states["/creating"].addChild(self.states["/creating/create_rect"])
        self.states["/creating"].addChild(self.states["/creating/create_buttons"])
        self.states["/creating/create_buttons"].addChild(self.states["/creating/create_buttons/create_a_button"])
        self.states["/creating/create_buttons"].addChild(self.states["/creating/create_buttons/start_a_button"])
        self.states["/creating/create_buttons"].addChild(self.states["/creating/create_buttons/check_next"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating"]
        self.states["/creating"].default_state = self.states["/creating/create_rect"]
        self.states["/creating/create_buttons"].default_state = self.states["/creating/create_buttons/create_a_button"]
        
        # transition /creating/create_rect
        _creating_create_rect_0 = Transition(self, self.states["/creating/create_rect"], [self.states["/creating/create_buttons"]])
        _creating_create_rect_0.setTrigger(None)
        self.states["/creating/create_rect"].addTransition(_creating_create_rect_0)
        
        # transition /creating/create_buttons/create_a_button
        _creating_create_buttons_create_a_button_0 = Transition(self, self.states["/creating/create_buttons/create_a_button"], [self.states["/creating/create_buttons/start_a_button"]])
        _creating_create_buttons_create_a_button_0.setAction(self._creating_create_buttons_create_a_button_0_exec)
        _creating_create_buttons_create_a_button_0.setTrigger(Event("instance_created", None))
        self.states["/creating/create_buttons/create_a_button"].addTransition(_creating_create_buttons_create_a_button_0)
        
        # transition /creating/create_buttons/start_a_button
        _creating_create_buttons_start_a_button_0 = Transition(self, self.states["/creating/create_buttons/start_a_button"], [self.states["/creating/create_buttons/check_next"]])
        _creating_create_buttons_start_a_button_0.setTrigger(Event("instance_started", None))
        self.states["/creating/create_buttons/start_a_button"].addTransition(_creating_create_buttons_start_a_button_0)
        
        # transition /creating/create_buttons/check_next
        _creating_create_buttons_check_next_0 = Transition(self, self.states["/creating/create_buttons/check_next"], [self.states["/creating/create_buttons/create_a_button"]])
        _creating_create_buttons_check_next_0.setAction(self._creating_create_buttons_check_next_0_exec)
        _creating_create_buttons_check_next_0.setTrigger(None)
        _creating_create_buttons_check_next_0.setGuard(self._creating_create_buttons_check_next_0_guard)
        self.states["/creating/create_buttons/check_next"].addTransition(_creating_create_buttons_check_next_0)
        _creating_create_buttons_check_next_1 = Transition(self, self.states["/creating/create_buttons/check_next"], [self.states["/running"]])
        _creating_create_buttons_check_next_1.setTrigger(None)
        _creating_create_buttons_check_next_1.setGuard(self._creating_create_buttons_check_next_1_guard)
        self.states["/creating/create_buttons/check_next"].addTransition(_creating_create_buttons_check_next_1)
        
        # transition /running
        _running_0 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_0.setAction(self._running_0_exec)
        _running_0.setTrigger(Event("button_pressed", None))
        self.states["/running"].addTransition(_running_0)
    
    def _creating_create_rect_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'grey', 'outline': 'black'}, self.inports['control_ui']]))
        self.big_step.outputEvent(Event("create_text", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], 20, 'Elevator Controls', self.inports['control_ui']]))
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [self.canvas_id, ui.EVENTS.MOUSE_MOVE, 'mouse_move', self.inports['control_ui']]))
    
    def _creating_create_buttons_create_a_button_enter(self):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "button", "ElevatorButton", self.canvas_id, self.button_num]))
    
    def _creating_create_buttons_create_a_button_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _creating_create_buttons_check_next_0_exec(self, parameters):
        self.button_num -= 1
    
    def _creating_create_buttons_check_next_0_guard(self, parameters):
        return self.button_num != 0
    
    def _creating_create_buttons_check_next_1_guard(self, parameters):
        return self.button_num == 0
    
    def _running_0_exec(self, parameters):
        floor = parameters[0]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("move_elevator", None, [0])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class ElevatorControls(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["button"] = self.addOutPort("button")
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["parent"] = self.addOutPort("parent")
        self.control_ui = self.addInPort("control_ui")
    
    def constructObject(self, parameters):
        new_instance = ElevatorControlsInstance(self, parameters[2])
        return new_instance

class ElevatorButtonInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id, number):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["parent"] = Association("ElevatorControls", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        ElevatorButtonInstance.user_defined_constructor(self, canvas_id, number)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("button_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["button_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id, number):
        self.canvas_id = canvas_id;
        self.button_id = None;
        
        self.dim = {'x': 120, 'y': (50 + (FLOORS * 30))}
        self.pos = {'x': CANVAS_DIMS[0] - ((self.dim['x'] / 2) + 10), 'y': (self.dim['y'] / 2) + 10}
        self.r = 10
        self.number = number;
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating
        self.states["/creating"] = State(1, "/creating", self)
        self.states["/creating"].setEnter(self._creating_enter)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # add children
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/running"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating"]
        
        # transition /creating
        _creating_0 = Transition(self, self.states["/creating"], [self.states["/running"]])
        _creating_0.setAction(self._creating_0_exec)
        _creating_0.setTrigger(Event("circle_created", None))
        self.states["/creating"].addTransition(_creating_0)
        
        # transition /running
        _running_0 = Transition(self, self.states["/running"], [self.states["/running"]])
        _running_0.setAction(self._running_0_exec)
        _running_0.setTrigger(Event("button_click", self.getInPortName("button_ui")))
        _running_0.setGuard(self._running_0_guard)
        self.states["/running"].addTransition(_running_0)
    
    def _creating_enter(self):
        self.big_step.outputEvent(Event("create_circle", self.getOutPortName("ui"), [self.canvas_id, CANVAS_DIMS[0] - 70, 45 + (30 * (FLOORS - self.number)) , 10, {'fill':'black', 'outline': 'black'}, self.inports['button_ui']]))
        self.big_step.outputEvent(Event("create_text", self.getOutPortName("ui"), [self.canvas_id, CANVAS_DIMS[0] - 70, 45 + (30 * (FLOORS - self.number)) , str(self.number), self.inports['button_ui']]))
    
    def _creating_0_exec(self, parameters):
        canvas_id = parameters[0]
        circle_id = parameters[1]
        self.button_id = circle_id
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [canvas_id, circle_id, ui.EVENTS.MOUSE_PRESS, 'button_click', self.inports['button_ui']]))
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_MOVE, 'mouse_move', self.inports['button_ui']]))
    
    def _running_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("button_pressed", None, [self.number])]))
        self.big_step.outputEvent(Event("set_element_color", self.getOutPortName("ui"), [self.canvas_id, self.button_id, '#ff0']))
    
    def _running_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class ElevatorButton(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["parent"] = self.addOutPort("parent")
        self.button_ui = self.addInPort("button_ui")
    
    def constructObject(self, parameters):
        new_instance = ElevatorButtonInstance(self, parameters[2], parameters[3])
        return new_instance

class ElevatorInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        ElevatorInstance.user_defined_constructor(self, canvas_id)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("elevator_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["elevator_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id):
        self.canvas_id = canvas_id;
        
        self.is_open = False;
        
        elevator_height = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': elevator_height, 'y': elevator_height};
        self.vel = -2;
        self.pos = {'x': FLOOR_LENGTH + (elevator_height / 2), 'y': (CANVAS_DIMS[1] - (elevator_height / 2))};
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /root
        self.states["/root"] = State(1, "/root", self)
        
        # state /root/waiting
        self.states["/root/waiting"] = State(2, "/root/waiting", self)
        
        # state /root/creating_elevator
        self.states["/root/creating_elevator"] = State(3, "/root/creating_elevator", self)
        self.states["/root/creating_elevator"].setEnter(self._root_creating_elevator_enter)
        
        # state /root/running
        self.states["/root/running"] = State(4, "/root/running", self)
        
        # state /root/running/waiting
        self.states["/root/running/waiting"] = State(5, "/root/running/waiting", self)
        
        # state /root/running/move
        self.states["/root/running/move"] = State(6, "/root/running/move", self)
        self.states["/root/running/move"].setEnter(self._root_running_move_enter)
        self.states["/root/running/move"].setExit(self._root_running_move_exit)
        
        # add children
        self.states[""].addChild(self.states["/root"])
        self.states["/root"].addChild(self.states["/root/waiting"])
        self.states["/root"].addChild(self.states["/root/creating_elevator"])
        self.states["/root"].addChild(self.states["/root/running"])
        self.states["/root/running"].addChild(self.states["/root/running/waiting"])
        self.states["/root/running"].addChild(self.states["/root/running/move"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/root"]
        self.states["/root"].default_state = self.states["/root/waiting"]
        self.states["/root/running"].default_state = self.states["/root/running/waiting"]
        
        # transition /root/waiting
        _root_waiting_0 = Transition(self, self.states["/root/waiting"], [self.states["/root/creating_elevator"]])
        _root_waiting_0.setAction(self._root_waiting_0_exec)
        _root_waiting_0.setTrigger(Event("set_association_name", None))
        self.states["/root/waiting"].addTransition(_root_waiting_0)
        
        # transition /root/creating_elevator
        _root_creating_elevator_0 = Transition(self, self.states["/root/creating_elevator"], [self.states["/root/running"]])
        _root_creating_elevator_0.setAction(self._root_creating_elevator_0_exec)
        _root_creating_elevator_0.setTrigger(Event("rectangle_created", None))
        self.states["/root/creating_elevator"].addTransition(_root_creating_elevator_0)
        
        # transition /root/running/waiting
        _root_running_waiting_0 = Transition(self, self.states["/root/running/waiting"], [self.states["/root/running/move"]])
        _root_running_waiting_0.setTrigger(Event("move_elevator", None))
        self.states["/root/running/waiting"].addTransition(_root_running_waiting_0)
        
        # transition /root/running/move
        _root_running_move_0 = Transition(self, self.states["/root/running/move"], [self.states["/root/running/move"]])
        _root_running_move_0.setAction(self._root_running_move_0_exec)
        _root_running_move_0.setTrigger(Event("_0after"))
        self.states["/root/running/move"].addTransition(_root_running_move_0)
        _root_running_move_1 = Transition(self, self.states["/root/running/move"], [self.states["/root/running/waiting"]])
        _root_running_move_1.setTrigger(None)
        _root_running_move_1.setGuard(self._root_running_move_1_guard)
        self.states["/root/running/move"].addTransition(_root_running_move_1)
    
    def _root_creating_elevator_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['elevator_ui']]))
    
    def _root_running_move_enter(self):
        self.addTimer(0, 0.02)
    
    def _root_running_move_exit(self):
        self.removeTimer(0)
    
    def _root_waiting_0_exec(self, parameters):
        association_name = parameters[0]
        canvas_id = parameters[1]
        window_id = parameters[2]
        self.association_name = association_name
        self.canvas_id = canvas_id
        self.window_id = window_id
    
    def _root_creating_elevator_0_exec(self, parameters):
        canvas_id = parameters[0]
        rect_id = parameters[1]
        self.elevator_id = rect_id
    
    def _root_running_move_0_exec(self, parameters):
        self.big_step.outputEvent(Event("set_element_pos", self.getOutPortName("ui"), [self.canvas_id, self.elevator_id, self.pos['x'], self.pos['y']]))
        self.pos['y'] += self.vel
    
    def _root_running_move_1_guard(self, parameters):
        return (self.pos['y'] - (self.dim['y']/2)) < 0
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/root"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Elevator(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["parent"] = self.addOutPort("parent")
        self.elevator_ui = self.addInPort("elevator_ui")
    
    def constructObject(self, parameters):
        new_instance = ElevatorInstance(self, parameters[2])
        return new_instance

class BallInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id, floor_num, x, y):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.canvas_id = None
        self.pos = None
        
        # call user defined constructor
        BallInstance.user_defined_constructor(self, canvas_id, floor_num, x, y)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("ball_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["ball_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id, floor_num, x, y):
        self.canvas_id = canvas_id;
        self.floor_num = floor_num;
        self.r = 5.0;
        self.vel = {'x': random.uniform(-5.0, 5.0), 'y': random.uniform(-5.0, 5.0)};
        self.pos = {'x': x, 'y': y};
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /main_behaviour
        self.states["/main_behaviour"] = State(1, "/main_behaviour", self)
        
        # state /main_behaviour/initializing
        self.states["/main_behaviour/initializing"] = State(2, "/main_behaviour/initializing", self)
        
        # state /main_behaviour/creating_circle
        self.states["/main_behaviour/creating_circle"] = State(3, "/main_behaviour/creating_circle", self)
        self.states["/main_behaviour/creating_circle"].setEnter(self._main_behaviour_creating_circle_enter)
        
        # state /main_behaviour/bouncing
        self.states["/main_behaviour/bouncing"] = State(4, "/main_behaviour/bouncing", self)
        self.states["/main_behaviour/bouncing"].setEnter(self._main_behaviour_bouncing_enter)
        self.states["/main_behaviour/bouncing"].setExit(self._main_behaviour_bouncing_exit)
        
        # state /main_behaviour/dragging
        self.states["/main_behaviour/dragging"] = State(5, "/main_behaviour/dragging", self)
        
        # state /main_behaviour/selected
        self.states["/main_behaviour/selected"] = State(6, "/main_behaviour/selected", self)
        
        # state /main_behaviour/ball_delete
        self.states["/main_behaviour/ball_delete"] = State(7, "/main_behaviour/ball_delete", self)
        
        # state /deleted
        self.states["/deleted"] = State(8, "/deleted", self)
        
        # add children
        self.states[""].addChild(self.states["/main_behaviour"])
        self.states[""].addChild(self.states["/deleted"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/initializing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/creating_circle"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/bouncing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/dragging"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/selected"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/ball_delete"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/main_behaviour"]
        self.states["/main_behaviour"].default_state = self.states["/main_behaviour/initializing"]
        
        # transition /main_behaviour/initializing
        _main_behaviour_initializing_0 = Transition(self, self.states["/main_behaviour/initializing"], [self.states["/main_behaviour/creating_circle"]])
        _main_behaviour_initializing_0.setAction(self._main_behaviour_initializing_0_exec)
        _main_behaviour_initializing_0.setTrigger(Event("set_association_name", None))
        self.states["/main_behaviour/initializing"].addTransition(_main_behaviour_initializing_0)
        
        # transition /main_behaviour/creating_circle
        _main_behaviour_creating_circle_0 = Transition(self, self.states["/main_behaviour/creating_circle"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_creating_circle_0.setAction(self._main_behaviour_creating_circle_0_exec)
        _main_behaviour_creating_circle_0.setTrigger(Event("circle_created", None))
        self.states["/main_behaviour/creating_circle"].addTransition(_main_behaviour_creating_circle_0)
        
        # transition /main_behaviour/bouncing
        _main_behaviour_bouncing_0 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_0.setAction(self._main_behaviour_bouncing_0_exec)
        _main_behaviour_bouncing_0.setTrigger(Event("_0after"))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_0)
        _main_behaviour_bouncing_1 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/ball_delete"]])
        _main_behaviour_bouncing_1.setTrigger(None)
        _main_behaviour_bouncing_1.setGuard(self._main_behaviour_bouncing_1_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_1)
        _main_behaviour_bouncing_2 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/selected"]])
        _main_behaviour_bouncing_2.setAction(self._main_behaviour_bouncing_2_exec)
        _main_behaviour_bouncing_2.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_bouncing_2.setGuard(self._main_behaviour_bouncing_2_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_2)
        _main_behaviour_bouncing_3 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_3.setAction(self._main_behaviour_bouncing_3_exec)
        _main_behaviour_bouncing_3.setTrigger(Event("update_bounds", None))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_3)
        
        # transition /main_behaviour/dragging
        _main_behaviour_dragging_0 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_dragging_0.setAction(self._main_behaviour_dragging_0_exec)
        _main_behaviour_dragging_0.setTrigger(Event("mouse_move", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_0)
        _main_behaviour_dragging_1 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_dragging_1.setAction(self._main_behaviour_dragging_1_exec)
        _main_behaviour_dragging_1.setTrigger(Event("mouse_release", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_1)
        
        # transition /main_behaviour/selected
        _main_behaviour_selected_0 = Transition(self, self.states["/main_behaviour/selected"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_selected_0.setAction(self._main_behaviour_selected_0_exec)
        _main_behaviour_selected_0.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_selected_0.setGuard(self._main_behaviour_selected_0_guard)
        self.states["/main_behaviour/selected"].addTransition(_main_behaviour_selected_0)
        
        # transition /main_behaviour/ball_delete
        _main_behaviour_ball_delete_0 = Transition(self, self.states["/main_behaviour/ball_delete"], [self.states["/deleted"]])
        _main_behaviour_ball_delete_0.setAction(self._main_behaviour_ball_delete_0_exec)
        _main_behaviour_ball_delete_0.setTrigger(Event("delete_self", None))
        self.states["/main_behaviour/ball_delete"].addTransition(_main_behaviour_ball_delete_0)
    
    def _main_behaviour_creating_circle_enter(self):
        self.big_step.outputEvent(Event("create_circle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.r, {'fill':'#000'}, self.inports['ball_ui']]))
    
    def _main_behaviour_bouncing_enter(self):
        self.addTimer(0, 0.02)
    
    def _main_behaviour_bouncing_exit(self):
        self.removeTimer(0)
    
    def _main_behaviour_initializing_0_exec(self, parameters):
        association_name = parameters[0]
        self.association_name = association_name
    
    def _main_behaviour_creating_circle_0_exec(self, parameters):
        canvas_id = parameters[0]
        circle_id = parameters[1]
        self.circle_id = circle_id
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_PRESS, 'mouse_press', self.inports['ball_ui']]))
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_MOVE, 'mouse_move', self.inports['ball_ui']]))
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_RELEASE, 'mouse_release', self.inports['ball_ui']]))
    
    def _main_behaviour_bouncing_0_exec(self, parameters):
        if self.floor_num == -1:
            if self.pos['x'] - self.r < self.rect_pos['x'] - (self.rect_dim['x'] / 2):
                self.pos['x'] = self.rect_pos['x'] - (self.rect_dim['x'] / 2) + self.r  # Correct position
                self.vel['x'] = -self.vel['x'] + self.rect_vel['x']
            elif self.pos['x'] + self.r > self.rect_pos['x'] + (self.rect_dim['x'] / 2):
                self.pos['x'] = self.rect_pos['x'] + (self.rect_dim['x'] / 2) - self.r  # Correct position
                self.vel['x'] = -self.vel['x'] + self.rect_vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < self.rect_pos['y'] - (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] - (self.rect_dim['y'] / 2) + self.r  # Correct position
                self.vel['y'] = -self.vel['y'] + self.rect_vel['y']
            elif self.pos['y'] + self.r > self.rect_pos['y'] + (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] + (self.rect_dim['y'] / 2) - self.r  # Correct position
                self.vel['y'] = -self.vel['y'] + self.rect_vel['y']
        else:
            floor_height = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
            floor_dim = {'x': FLOOR_LENGTH, 'y': floor_height};
            floor_pos = {'x': FLOOR_LENGTH / 2, 'y': (floor_height /2) + (self.floor_num * (floor_height + FLOOR_SPACE))};
        
            if self.pos['x'] - self.r < floor_pos['x'] - (floor_dim['x'] / 2):
                self.pos['x'] = floor_pos['x'] - (floor_dim['x'] / 2) + self.r  # Correct position
                self.vel['x'] = -self.vel['x']
            elif self.pos['x'] + self.r > floor_pos['x'] + (floor_dim['x'] / 2):
                self.pos['x'] = floor_pos['x'] + (floor_dim['x'] / 2) - self.r  # Correct position
                self.vel['x'] = -self.vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < floor_pos['y'] - (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] - (floor_dim['y'] / 2) + self.r  # Correct position
                self.vel['y'] = -self.vel['y']
            elif self.pos['y'] + self.r > floor_pos['y'] + (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] + (floor_dim['y'] / 2) - self.r  # Correct position
                self.vel['y'] = -self.vel['y']
        self.big_step.outputEvent(Event("move_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, self.vel['x'], self.vel['y']]))
        self.pos['x'] += self.vel['x']
        self.pos['y'] += self.vel['y']
    
    def _main_behaviour_bouncing_1_guard(self, parameters):
        return self.pos['x'] - self.r < 2
    
    def _main_behaviour_bouncing_2_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEvent(Event("set_element_color", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, '#ff0']))
    
    def _main_behaviour_bouncing_2_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_bouncing_3_exec(self, parameters):
        pos = parameters[0]
        dim = parameters[1]
        vel = parameters[2]
        self.rect_pos = pos
        self.rect_dim = dim
        self.rect_vel = vel
    
    def _main_behaviour_dragging_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        # Always keep ball within canvas:
        x = min(max(0+self.r, x), CANVAS_DIMS[0]-self.r)
        y = min(max(0+self.r, y), CANVAS_DIMS[1]-self.r)
        
        dx = x - self.pos['x']
        dy = y - self.pos['y']
        
        self.vel = {
            'x': (1-self.smooth)*dx + self.smooth*self.vel['x'],
            'y': (1-self.smooth)*dy + self.smooth*self.vel['y']
        }
        
        self.pos = {'x': x, 'y': y}
        self.big_step.outputEvent(Event("set_element_pos", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, x-self.r, y-self.r]))
    
    def _main_behaviour_dragging_1_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        self.big_step.outputEvent(Event("set_element_color", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, '#f00']))
    
    def _main_behaviour_selected_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.mouse_pos = {'x':x, 'y':y};
    
    def _main_behaviour_selected_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_ball_delete_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("delete_ball", None, [self.association_name])]))
        self.big_step.outputEvent(Event("destroy_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/main_behaviour"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Ball(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["parent"] = self.addOutPort("parent")
        self.ball_ui = self.addInPort("ball_ui")
    
    def constructObject(self, parameters):
        new_instance = BallInstance(self, parameters[2], parameters[3], parameters[4], parameters[5])
        return new_instance

class ObjectManagerState:
    def __init__(self):
        self.to_send = [("MainApp", "MainApp", Event("start_instance", None, ["MainApp[0]"], 0))]

class ObjectManager(TheObjectManager):
    def __init__(self, name):
        TheObjectManager.__init__(self, name)
        self.State = ObjectManagerState()
        self.input = self.addInPort("input")
        self.output["MainApp"] = self.addOutPort()
        self.output["Floor"] = self.addOutPort()
        self.output["ElevatorControls"] = self.addOutPort()
        self.output["ElevatorButton"] = self.addOutPort()
        self.output["Elevator"] = self.addOutPort()
        self.output["Ball"] = self.addOutPort()

class Controller(CoupledDEVS):
    def __init__(self, name):
        CoupledDEVS.__init__(self, name)
        self.in_ui = self.addInPort("ui")
        Ports.addInputPort("ui")
        self.out_ui = self.addOutPort("ui")
        Ports.addOutputPort("ui")
        self.objectmanager = self.addSubModel(ObjectManager("ObjectManager"))
        self.atomic0 = self.addSubModel(MainApp("MainApp"))
        self.atomic1 = self.addSubModel(Floor("Floor"))
        self.atomic2 = self.addSubModel(ElevatorControls("ElevatorControls"))
        self.atomic3 = self.addSubModel(ElevatorButton("ElevatorButton"))
        self.atomic4 = self.addSubModel(Elevator("Elevator"))
        self.atomic5 = self.addSubModel(Ball("Ball"))
        self.connectPorts(self.atomic0.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["MainApp"], self.atomic0.obj_manager_in)
        self.connectPorts(self.atomic0.outputs["floor"], self.atomic1.input)
        self.connectPorts(self.atomic0.outputs["controls"], self.atomic2.input)
        self.connectPorts(self.atomic0.outputs["elevator"], self.atomic4.input)
        self.connectPorts(self.atomic1.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Floor"], self.atomic1.obj_manager_in)
        self.connectPorts(self.atomic1.outputs["balls"], self.atomic5.input)
        self.connectPorts(self.atomic1.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic2.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["ElevatorControls"], self.atomic2.obj_manager_in)
        self.connectPorts(self.atomic2.outputs["button"], self.atomic3.input)
        self.connectPorts(self.atomic2.outputs["balls"], self.atomic5.input)
        self.connectPorts(self.atomic2.outputs["parent"], self.atomic4.input)
        self.connectPorts(self.atomic3.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["ElevatorButton"], self.atomic3.obj_manager_in)
        self.connectPorts(self.atomic3.outputs["parent"], self.atomic2.input)
        self.connectPorts(self.atomic4.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Elevator"], self.atomic4.obj_manager_in)
        self.connectPorts(self.atomic4.outputs["balls"], self.atomic5.input)
        self.connectPorts(self.atomic4.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic5.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Ball"], self.atomic5.obj_manager_in)
        self.connectPorts(self.atomic5.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic0.output, self.out_ui)
        self.connectPorts(self.atomic1.output, self.out_ui)
        self.connectPorts(self.atomic2.output, self.out_ui)
        self.connectPorts(self.atomic3.output, self.out_ui)
        self.connectPorts(self.atomic4.output, self.out_ui)
        self.connectPorts(self.atomic5.output, self.out_ui)