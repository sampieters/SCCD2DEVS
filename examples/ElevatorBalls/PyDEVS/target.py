"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration) and Sam Pieters (DEVS)

Model author: Sam Pieters
Model name:   Elevator Balls

"""

from sccd.runtime.DEVS_statecharts_core import *
import sccd.runtime.libs.ui_v2 as ui
import random
import time

CANVAS_DIMS = (800, 550)
FLOOR_LENGTH = 350
FLOOR_SPACE = 50
FLOORS = 4

# package "Elevator Balls"

class MainAppInstance(RuntimeClassBase):
    def __init__(self, atomdevs):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["floor"] = Association("Floor", 2, -1)
        self.associations["elevator"] = Association("Elevator", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.num_floors = None
        self.floor_dimensions = None
        
        # call user defined constructor
        MainAppInstance.user_defined_constructor(self)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("field_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["field_ui"] = port_name
    
    def user_defined_constructor(self):
        self.num_floors = 0
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_window
        self.states["/creating_window"] = State(1, "/creating_window", self)
        self.states["/creating_window"].setEnter(self._creating_window_enter)
        
        # state /creating_canvas
        self.states["/creating_canvas"] = State(2, "/creating_canvas", self)
        self.states["/creating_canvas"].setEnter(self._creating_canvas_enter)
        
        # state /create_floors
        self.states["/create_floors"] = State(3, "/create_floors", self)
        
        # state /wait
        self.states["/wait"] = State(4, "/wait", self)
        
        # state /create_elevator
        self.states["/create_elevator"] = State(5, "/create_elevator", self)
        
        # state /creating
        self.states["/creating"] = State(6, "/creating", self)
        
        # state /waiting
        self.states["/waiting"] = State(7, "/waiting", self)
        
        # add children
        self.states[""].addChild(self.states["/creating_window"])
        self.states[""].addChild(self.states["/creating_canvas"])
        self.states[""].addChild(self.states["/create_floors"])
        self.states[""].addChild(self.states["/wait"])
        self.states[""].addChild(self.states["/create_elevator"])
        self.states[""].addChild(self.states["/creating"])
        self.states[""].addChild(self.states["/waiting"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_window"]
        
        # transition /creating_window
        _creating_window_0 = Transition(self, self.states["/creating_window"], [self.states["/creating_canvas"]])
        _creating_window_0.setAction(self._creating_window_0_exec)
        _creating_window_0.setTrigger(Event("window_created", None))
        self.states["/creating_window"].addTransition(_creating_window_0)
        
        # transition /creating_canvas
        _creating_canvas_0 = Transition(self, self.states["/creating_canvas"], [self.states["/create_floors"]])
        _creating_canvas_0.setAction(self._creating_canvas_0_exec)
        _creating_canvas_0.setTrigger(Event("canvas_created", None))
        self.states["/creating_canvas"].addTransition(_creating_canvas_0)
        
        # transition /create_floors
        _create_floors_0 = Transition(self, self.states["/create_floors"], [self.states["/create_elevator"]])
        _create_floors_0.setTrigger(None)
        _create_floors_0.setGuard(self._create_floors_0_guard)
        self.states["/create_floors"].addTransition(_create_floors_0)
        _create_floors_1 = Transition(self, self.states["/create_floors"], [self.states["/wait"]])
        _create_floors_1.setAction(self._create_floors_1_exec)
        _create_floors_1.setTrigger(None)
        _create_floors_1.setGuard(self._create_floors_1_guard)
        self.states["/create_floors"].addTransition(_create_floors_1)
        
        # transition /wait
        _wait_0 = Transition(self, self.states["/wait"], [self.states["/wait"]])
        _wait_0.setAction(self._wait_0_exec)
        _wait_0.setTrigger(Event("instance_created", None))
        self.states["/wait"].addTransition(_wait_0)
        _wait_1 = Transition(self, self.states["/wait"], [self.states["/create_floors"]])
        _wait_1.setTrigger(Event("instance_started", None))
        self.states["/wait"].addTransition(_wait_1)
        
        # transition /create_elevator
        _create_elevator_0 = Transition(self, self.states["/create_elevator"], [self.states["/creating"]])
        _create_elevator_0.setAction(self._create_elevator_0_exec)
        _create_elevator_0.setTrigger(None)
        self.states["/create_elevator"].addTransition(_create_elevator_0)
        
        # transition /creating
        _creating_0 = Transition(self, self.states["/creating"], [self.states["/waiting"]])
        _creating_0.setAction(self._creating_0_exec)
        _creating_0.setTrigger(Event("instance_created", None))
        self.states["/creating"].addTransition(_creating_0)
    
    def _creating_window_enter(self):
        self.big_step.outputEvent(Event("create_window", self.getOutPortName("ui"), [CANVAS_DIMS[0], CANVAS_DIMS[1], "Bouncing Balls Elevator", self.inports['field_ui']]))
    
    def _creating_canvas_enter(self):
        self.big_step.outputEvent(Event("create_canvas", self.getOutPortName("ui"), [self.window_id, CANVAS_DIMS[0], CANVAS_DIMS[1] - 200, {'background':'#fff'}, self.inports['field_ui']]))
    
    def _creating_window_0_exec(self, parameters):
        window_id = parameters[0]
        self.window_id = window_id
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.WINDOW_CLOSE, 'window_close', self.inports['field_ui']]))
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [window_id, ui.EVENTS.KEY_PRESS, 'key_press', self.inports['field_ui']]))
    
    def _creating_canvas_0_exec(self, parameters):
        canvas_id = parameters[0]
        self.canvas_id = canvas_id
    
    def _create_floors_0_guard(self, parameters):
        return self.num_floors == FLOORS
    
    def _create_floors_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "floor", "Floor", self.canvas_id, self.num_floors]))
        self.num_floors += 1
    
    def _create_floors_1_guard(self, parameters):
        return self.num_floors != FLOORS
    
    def _wait_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _create_elevator_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "elevator", "Elevator", self.canvas_id]))
    
    def _creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name, self.canvas_id, self.window_id])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_window"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class MainApp(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["floor"] = self.addOutPort("floor")
        self.outputs["elevator"] = self.addOutPort("elevator")
        self.field_ui = self.addInPort("field_ui")
        self.instances[self.next_instance] = MainAppInstance(self)
        self.next_instance = self.next_instance + 1
    
    def constructObject(self, parameters):
        new_instance = MainAppInstance(self)
        return new_instance

class FloorInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id, floor_num):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        FloorInstance.user_defined_constructor(self, canvas_id, floor_num)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("floor_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["floor_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id, floor_num):
        self.canvas_id = canvas_id;
        self.floor_num = floor_num;
        
        y_dim = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': FLOOR_LENGTH, 'y': y_dim};
        self.pos = {'x': FLOOR_LENGTH / 2, 'y': (y_dim /2) + (self.floor_num * (y_dim + FLOOR_SPACE))};
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /creating_floor
        self.states["/creating_floor"] = State(1, "/creating_floor", self)
        self.states["/creating_floor"].setEnter(self._creating_floor_enter)
        
        # state /running
        self.states["/running"] = State(2, "/running", self)
        
        # state /running/create_random_ball
        self.states["/running/create_random_ball"] = State(3, "/running/create_random_ball", self)
        self.states["/running/create_random_ball"].setEnter(self._running_create_random_ball_enter)
        self.states["/running/create_random_ball"].setExit(self._running_create_random_ball_exit)
        
        # state /running/wait
        self.states["/running/wait"] = State(4, "/running/wait", self)
        
        # add children
        self.states[""].addChild(self.states["/creating_floor"])
        self.states[""].addChild(self.states["/running"])
        self.states["/running"].addChild(self.states["/running/create_random_ball"])
        self.states["/running"].addChild(self.states["/running/wait"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/creating_floor"]
        self.states["/running"].default_state = self.states["/running/create_random_ball"]
        
        # transition /creating_floor
        _creating_floor_0 = Transition(self, self.states["/creating_floor"], [self.states["/running"]])
        _creating_floor_0.setTrigger(Event("rectangle_created", None))
        self.states["/creating_floor"].addTransition(_creating_floor_0)
        
        # transition /running/create_random_ball
        _running_create_random_ball_0 = Transition(self, self.states["/running/create_random_ball"], [self.states["/running/wait"]])
        _running_create_random_ball_0.setAction(self._running_create_random_ball_0_exec)
        _running_create_random_ball_0.setTrigger(Event("_0after"))
        self.states["/running/create_random_ball"].addTransition(_running_create_random_ball_0)
        _running_create_random_ball_1 = Transition(self, self.states["/running/create_random_ball"], [self.states["/running/create_random_ball"]])
        _running_create_random_ball_1.setAction(self._running_create_random_ball_1_exec)
        _running_create_random_ball_1.setTrigger(Event("delete_ball", None))
        self.states["/running/create_random_ball"].addTransition(_running_create_random_ball_1)
        
        # transition /running/wait
        _running_wait_0 = Transition(self, self.states["/running/wait"], [self.states["/running/create_random_ball"]])
        _running_wait_0.setAction(self._running_wait_0_exec)
        _running_wait_0.setTrigger(Event("instance_created", None))
        self.states["/running/wait"].addTransition(_running_wait_0)
    
    def _creating_floor_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['floor_ui']]))
    
    def _running_create_random_ball_enter(self):
        self.addTimer(0, random.randint(2, 10))
    
    def _running_create_random_ball_exit(self):
        self.removeTimer(0)
    
    def _running_create_random_ball_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "balls", "Ball", self.canvas_id, self.floor_num, 10, self.pos['y']]))
    
    def _running_create_random_ball_1_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("delete_instance", None, [self, association_name]))
    
    def _running_wait_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/creating_floor"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Floor(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["parent"] = self.addOutPort("parent")
        self.floor_ui = self.addInPort("floor_ui")
    
    def constructObject(self, parameters):
        new_instance = FloorInstance(self, parameters[2], parameters[3])
        return new_instance

class ElevatorInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["balls"] = Association("Ball", 0, -1)
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.window_id = None
        self.canvas_id = None
        self.elevator_id = None
        
        # call user defined constructor
        ElevatorInstance.user_defined_constructor(self, canvas_id)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("elevator_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["elevator_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id):
        self.canvas_id = canvas_id;
        self.button_ids = {
            'up': None,
            'down': None,
            'open': None
        };
        self.open_button = None;
        self.is_open = False;
        
        elevator_height = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
        
        self.dim = {'x': elevator_height, 'y': elevator_height};
        self.vel = {'x': 0, 'y': -2};
        self.pos = {'x': FLOOR_LENGTH + (elevator_height / 2), 'y': 75};
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /root
        self.states["/root"] = State(1, "/root", self)
        
        # state /root/waiting
        self.states["/root/waiting"] = State(2, "/root/waiting", self)
        
        # state /root/creating_elevator
        self.states["/root/creating_elevator"] = State(3, "/root/creating_elevator", self)
        self.states["/root/creating_elevator"].setEnter(self._root_creating_elevator_enter)
        
        # state /root/running
        self.states["/root/running"] = State(4, "/root/running", self)
        self.states["/root/running"].setEnter(self._root_running_enter)
        self.states["/root/running"].setExit(self._root_running_exit)
        
        # add children
        self.states[""].addChild(self.states["/root"])
        self.states["/root"].addChild(self.states["/root/waiting"])
        self.states["/root"].addChild(self.states["/root/creating_elevator"])
        self.states["/root"].addChild(self.states["/root/running"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/root"]
        self.states["/root"].default_state = self.states["/root/waiting"]
        
        # transition /root/waiting
        _root_waiting_0 = Transition(self, self.states["/root/waiting"], [self.states["/root/creating_elevator"]])
        _root_waiting_0.setAction(self._root_waiting_0_exec)
        _root_waiting_0.setTrigger(Event("set_association_name", None))
        self.states["/root/waiting"].addTransition(_root_waiting_0)
        
        # transition /root/creating_elevator
        _root_creating_elevator_0 = Transition(self, self.states["/root/creating_elevator"], [self.states["/root/running"]])
        _root_creating_elevator_0.setAction(self._root_creating_elevator_0_exec)
        _root_creating_elevator_0.setTrigger(Event("rectangle_created", None))
        self.states["/root/creating_elevator"].addTransition(_root_creating_elevator_0)
        
        # transition /root/running
        _root_running_0 = Transition(self, self.states["/root/running"], [self.states["/root/running"]])
        _root_running_0.setAction(self._root_running_0_exec)
        _root_running_0.setTrigger(Event("_0after"))
        self.states["/root/running"].addTransition(_root_running_0)
        _root_running_1 = Transition(self, self.states["/root/running"], [self.states["/root/running"]])
        _root_running_1.setAction(self._root_running_1_exec)
        _root_running_1.setTrigger(Event("right_click", self.getInPortName("elevator_ui")))
        self.states["/root/running"].addTransition(_root_running_1)
        _root_running_2 = Transition(self, self.states["/root/running"], [self.states["/root/running"]])
        _root_running_2.setAction(self._root_running_2_exec)
        _root_running_2.setTrigger(Event("instance_created", None))
        self.states["/root/running"].addTransition(_root_running_2)
    
    def _root_creating_elevator_enter(self):
        self.big_step.outputEvent(Event("create_rectangle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.dim['x'], self.dim['y'], {'fill':'white', 'outline': 'black'}, self.inports['elevator_ui']]))
    
    def _root_running_enter(self):
        self.addTimer(0, 0.02)
    
    def _root_running_exit(self):
        self.removeTimer(0)
    
    def _root_waiting_0_exec(self, parameters):
        association_name = parameters[0]
        canvas_id = parameters[1]
        window_id = parameters[2]
        self.association_name = association_name
        self.canvas_id = canvas_id
        self.window_id = window_id
    
    def _root_creating_elevator_0_exec(self, parameters):
        canvas_id = parameters[0]
        rect_id = parameters[1]
        self.elevator_id = rect_id
        self.big_step.outputEvent(Event("bind_event", self.getOutPortName("ui"), [canvas_id, ui.EVENTS.MOUSE_RIGHT_CLICK, 'right_click', self.inports['elevator_ui']]))
    
    def _root_running_0_exec(self, parameters):
        # Invert velocity when colliding with canvas border:
        if self.pos['y']-(self.dim['y']/2) <= 0 or self.pos['y']+(self.dim['y']/2) >= CANVAS_DIMS[1]:
            self.vel['y'] = -self.vel['y'];
        self.big_step.outputEvent(Event("move_element", self.getOutPortName("ui"), [self.canvas_id, self.elevator_id, self.vel['x'], self.vel['y']]))
        self.pos['x'] += self.vel['x']
        self.pos['y'] += self.vel['y']
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'balls', Event("update_bounds", None, [self.pos, self.dim, self.vel])]))
    
    def _root_running_1_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEventOM(Event("create_instance", None, [self, "balls", "Ball", self.canvas_id, -1, x, y]))
    
    def _root_running_2_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/root"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Elevator(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["balls"] = self.addOutPort("balls")
        self.outputs["parent"] = self.addOutPort("parent")
        self.elevator_ui = self.addInPort("elevator_ui")
    
    def constructObject(self, parameters):
        new_instance = ElevatorInstance(self, parameters[2])
        return new_instance

class BallInstance(RuntimeClassBase):
    def __init__(self, atomdevs, canvas_id, floor_num, x, y):
        RuntimeClassBase.__init__(self, atomdevs)
        self.associations = {}
        self.associations["parent"] = Association("MainApp", 1, 1)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # user defined attributes
        self.canvas_id = None
        self.pos = None
        
        # call user defined constructor
        BallInstance.user_defined_constructor(self, canvas_id, floor_num, x, y)
        port_name = Ports.addInputPort("<narrow_cast>", self)
        atomdevs.addInPort(port_name)
        port_name = Ports.addInputPort("ball_ui", self)
        atomdevs.addInPort(port_name)
        atomdevs.port_mappings[port_name] = atomdevs.next_instance
        self.inports["ball_ui"] = port_name
    
    def user_defined_constructor(self, canvas_id, floor_num, x, y):
        self.canvas_id = canvas_id;
        self.floor_num = floor_num;
        self.r = 5.0;
        self.vel = {'x': random.uniform(-5.0, 5.0), 'y': random.uniform(-5.0, 5.0)};
        self.pos = {'x': x, 'y': y};
        self.smooth = 0.6; # value between 0 and 1
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, "", self)
        
        # state /main_behaviour
        self.states["/main_behaviour"] = State(1, "/main_behaviour", self)
        
        # state /main_behaviour/initializing
        self.states["/main_behaviour/initializing"] = State(2, "/main_behaviour/initializing", self)
        
        # state /main_behaviour/creating_circle
        self.states["/main_behaviour/creating_circle"] = State(3, "/main_behaviour/creating_circle", self)
        self.states["/main_behaviour/creating_circle"].setEnter(self._main_behaviour_creating_circle_enter)
        
        # state /main_behaviour/bouncing
        self.states["/main_behaviour/bouncing"] = State(4, "/main_behaviour/bouncing", self)
        self.states["/main_behaviour/bouncing"].setEnter(self._main_behaviour_bouncing_enter)
        self.states["/main_behaviour/bouncing"].setExit(self._main_behaviour_bouncing_exit)
        
        # state /main_behaviour/dragging
        self.states["/main_behaviour/dragging"] = State(5, "/main_behaviour/dragging", self)
        
        # state /main_behaviour/selected
        self.states["/main_behaviour/selected"] = State(6, "/main_behaviour/selected", self)
        
        # state /deleted
        self.states["/deleted"] = State(7, "/deleted", self)
        
        # add children
        self.states[""].addChild(self.states["/main_behaviour"])
        self.states[""].addChild(self.states["/deleted"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/initializing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/creating_circle"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/bouncing"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/dragging"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/selected"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/main_behaviour"]
        self.states["/main_behaviour"].default_state = self.states["/main_behaviour/initializing"]
        
        # transition /main_behaviour/initializing
        _main_behaviour_initializing_0 = Transition(self, self.states["/main_behaviour/initializing"], [self.states["/main_behaviour/creating_circle"]])
        _main_behaviour_initializing_0.setAction(self._main_behaviour_initializing_0_exec)
        _main_behaviour_initializing_0.setTrigger(Event("set_association_name", None))
        self.states["/main_behaviour/initializing"].addTransition(_main_behaviour_initializing_0)
        
        # transition /main_behaviour/creating_circle
        _main_behaviour_creating_circle_0 = Transition(self, self.states["/main_behaviour/creating_circle"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_creating_circle_0.setAction(self._main_behaviour_creating_circle_0_exec)
        _main_behaviour_creating_circle_0.setTrigger(Event("circle_created", None))
        self.states["/main_behaviour/creating_circle"].addTransition(_main_behaviour_creating_circle_0)
        
        # transition /main_behaviour/bouncing
        _main_behaviour_bouncing_0 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_0.setAction(self._main_behaviour_bouncing_0_exec)
        _main_behaviour_bouncing_0.setTrigger(Event("_0after"))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_0)
        _main_behaviour_bouncing_1 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_1.setAction(self._main_behaviour_bouncing_1_exec)
        _main_behaviour_bouncing_1.setTrigger(None)
        _main_behaviour_bouncing_1.setGuard(self._main_behaviour_bouncing_1_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_1)
        _main_behaviour_bouncing_2 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/selected"]])
        _main_behaviour_bouncing_2.setAction(self._main_behaviour_bouncing_2_exec)
        _main_behaviour_bouncing_2.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_bouncing_2.setGuard(self._main_behaviour_bouncing_2_guard)
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_2)
        _main_behaviour_bouncing_3 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_3.setAction(self._main_behaviour_bouncing_3_exec)
        _main_behaviour_bouncing_3.setTrigger(Event("update_bounds", None))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_3)
        
        # transition /main_behaviour/dragging
        _main_behaviour_dragging_0 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_dragging_0.setAction(self._main_behaviour_dragging_0_exec)
        _main_behaviour_dragging_0.setTrigger(Event("mouse_move", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_0)
        _main_behaviour_dragging_1 = Transition(self, self.states["/main_behaviour/dragging"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_dragging_1.setAction(self._main_behaviour_dragging_1_exec)
        _main_behaviour_dragging_1.setTrigger(Event("mouse_release", self.getInPortName("ball_ui")))
        self.states["/main_behaviour/dragging"].addTransition(_main_behaviour_dragging_1)
        
        # transition /main_behaviour/selected
        _main_behaviour_selected_0 = Transition(self, self.states["/main_behaviour/selected"], [self.states["/main_behaviour/dragging"]])
        _main_behaviour_selected_0.setAction(self._main_behaviour_selected_0_exec)
        _main_behaviour_selected_0.setTrigger(Event("mouse_press", self.getInPortName("ball_ui")))
        _main_behaviour_selected_0.setGuard(self._main_behaviour_selected_0_guard)
        self.states["/main_behaviour/selected"].addTransition(_main_behaviour_selected_0)
        _main_behaviour_selected_1 = Transition(self, self.states["/main_behaviour/selected"], [self.states["/deleted"]])
        _main_behaviour_selected_1.setAction(self._main_behaviour_selected_1_exec)
        _main_behaviour_selected_1.setTrigger(Event("delete_self", None))
        self.states["/main_behaviour/selected"].addTransition(_main_behaviour_selected_1)
    
    def _main_behaviour_creating_circle_enter(self):
        self.big_step.outputEvent(Event("create_circle", self.getOutPortName("ui"), [self.canvas_id, self.pos['x'], self.pos['y'], self.r, {'fill':'#000'}, self.inports['ball_ui']]))
    
    def _main_behaviour_bouncing_enter(self):
        self.addTimer(0, 0.02)
    
    def _main_behaviour_bouncing_exit(self):
        self.removeTimer(0)
    
    def _main_behaviour_initializing_0_exec(self, parameters):
        association_name = parameters[0]
        self.association_name = association_name
    
    def _main_behaviour_creating_circle_0_exec(self, parameters):
        canvas_id = parameters[0]
        circle_id = parameters[1]
        self.circle_id = circle_id
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_PRESS, 'mouse_press', self.inports['ball_ui']]))
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_MOVE, 'mouse_move', self.inports['ball_ui']]))
        self.big_step.outputEvent(Event("bind_canvas_event", self.getOutPortName("ui"), [self.canvas_id, circle_id, ui.EVENTS.MOUSE_RELEASE, 'mouse_release', self.inports['ball_ui']]))
    
    def _main_behaviour_bouncing_0_exec(self, parameters):
        if self.floor_num == -1:
            if self.pos['x'] - self.r < self.rect_pos['x'] - (self.rect_dim['x'] / 2):
                self.pos['x'] = self.rect_pos['x'] - (self.rect_dim['x'] / 2) + self.r  # Correct position
                self.vel['x'] = -self.vel['x'] + self.rect_vel['x']
            elif self.pos['x'] + self.r > self.rect_pos['x'] + (self.rect_dim['x'] / 2):
                self.pos['x'] = self.rect_pos['x'] + (self.rect_dim['x'] / 2) - self.r  # Correct position
                self.vel['x'] = -self.vel['x'] + self.rect_vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < self.rect_pos['y'] - (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] - (self.rect_dim['y'] / 2) + self.r  # Correct position
                self.vel['y'] = -self.vel['y'] + self.rect_vel['y']
            elif self.pos['y'] + self.r > self.rect_pos['y'] + (self.rect_dim['y'] / 2):
                self.pos['y'] = self.rect_pos['y'] + (self.rect_dim['y'] / 2) - self.r  # Correct position
                self.vel['y'] = -self.vel['y'] + self.rect_vel['y']
        else:
            floor_height = (CANVAS_DIMS[1] - ((FLOORS - 1) * FLOOR_SPACE)) / FLOORS
            floor_dim = {'x': FLOOR_LENGTH, 'y': floor_height};
            floor_pos = {'x': FLOOR_LENGTH / 2, 'y': (floor_height /2) + (self.floor_num * (floor_height + FLOOR_SPACE))};
        
            if self.pos['x'] - self.r < floor_pos['x'] - (floor_dim['x'] / 2):
                self.pos['x'] = floor_pos['x'] - (floor_dim['x'] / 2) + self.r  # Correct position
                self.vel['x'] = -self.vel['x']
            elif self.pos['x'] + self.r > floor_pos['x'] + (floor_dim['x'] / 2):
                self.pos['x'] = floor_pos['x'] + (floor_dim['x'] / 2) - self.r  # Correct position
                self.vel['x'] = -self.vel['x']
        
            # Check collision with the top and bottom borders
            if self.pos['y'] - self.r < floor_pos['y'] - (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] - (floor_dim['y'] / 2) + self.r  # Correct position
                self.vel['y'] = -self.vel['y']
            elif self.pos['y'] + self.r > floor_pos['y'] + (floor_dim['y'] / 2):
                self.pos['y'] = floor_pos['y'] + (floor_dim['y'] / 2) - self.r  # Correct position
                self.vel['y'] = -self.vel['y']
        self.big_step.outputEvent(Event("move_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, self.vel['x'], self.vel['y']]))
        self.pos['x'] += self.vel['x']
        self.pos['y'] += self.vel['y']
    
    def _main_behaviour_bouncing_1_exec(self, parameters):
        self.big_step.outputEvent(Event("destroy_element", self.getOutPortName("ui"), [self.canvas_id, self.circle_id]))
    
    def _main_behaviour_bouncing_1_guard(self, parameters):
        return self.pos['x'] - self.r < 6
    
    def _main_behaviour_bouncing_2_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.big_step.outputEvent(Event("set_element_color", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, '#ff0']))
    
    def _main_behaviour_bouncing_2_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_bouncing_3_exec(self, parameters):
        pos = parameters[0]
        dim = parameters[1]
        vel = parameters[2]
        self.rect_pos = pos
        self.rect_dim = dim
        self.rect_vel = vel
    
    def _main_behaviour_dragging_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        # Always keep ball within canvas:
        x = min(max(0+self.r, x), CANVAS_DIMS[0]-self.r)
        y = min(max(0+self.r, y), CANVAS_DIMS[1]-self.r)
        
        dx = x - self.pos['x']
        dy = y - self.pos['y']
        
        self.vel = {
            'x': (1-self.smooth)*dx + self.smooth*self.vel['x'],
            'y': (1-self.smooth)*dy + self.smooth*self.vel['y']
        }
        
        self.pos = {'x': x, 'y': y}
        self.big_step.outputEvent(Event("set_element_pos", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, x-self.r, y-self.r]))
    
    def _main_behaviour_dragging_1_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        self.big_step.outputEvent(Event("set_element_color", self.getOutPortName("ui"), [self.canvas_id, self.circle_id, '#f00']))
    
    def _main_behaviour_selected_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        self.mouse_pos = {'x':x, 'y':y};
    
    def _main_behaviour_selected_0_guard(self, parameters):
        x = parameters[0]
        y = parameters[1]
        button = parameters[2]
        return button == ui.MOUSE_BUTTONS.LEFT
    
    def _main_behaviour_selected_1_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("delete_ball", None, [self.association_name])]))
        self.big_step.outputEvent(Event("destroy_element", self.getOutPortName("ui"), [self.canvas_id, self.element_id]))
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/main_behaviour"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Ball(ObjectManagerBase):
    def __init__(self, name):
        ObjectManagerBase.__init__(self, name)
        self.input = self.addInPort("input")
        self.output = self.addOutPort("ui")
        self.outputs["parent"] = self.addOutPort("parent")
        self.ball_ui = self.addInPort("ball_ui")
    
    def constructObject(self, parameters):
        new_instance = BallInstance(self, parameters[2], parameters[3], parameters[4], parameters[5])
        return new_instance

class ObjectManagerState:
    def __init__(self):
        self.to_send = [("MainApp", "MainApp", Event("start_instance", None, ["MainApp[0]"], 0))]

class ObjectManager(TheObjectManager):
    def __init__(self, name):
        TheObjectManager.__init__(self, name)
        self.State = ObjectManagerState()
        self.input = self.addInPort("input")
        self.output["MainApp"] = self.addOutPort()
        self.output["Floor"] = self.addOutPort()
        self.output["Elevator"] = self.addOutPort()
        self.output["Ball"] = self.addOutPort()

class Controller(CoupledDEVS):
    def __init__(self, name):
        CoupledDEVS.__init__(self, name)
        self.in_ui = self.addInPort("ui")
        Ports.addInputPort("ui")
        self.out_ui = self.addOutPort("ui")
        Ports.addOutputPort("ui")
        self.objectmanager = self.addSubModel(ObjectManager("ObjectManager"))
        self.atomic0 = self.addSubModel(MainApp("MainApp"))
        self.atomic1 = self.addSubModel(Floor("Floor"))
        self.atomic2 = self.addSubModel(Elevator("Elevator"))
        self.atomic3 = self.addSubModel(Ball("Ball"))
        self.connectPorts(self.atomic0.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["MainApp"], self.atomic0.obj_manager_in)
        self.connectPorts(self.atomic0.outputs["floor"], self.atomic1.input)
        self.connectPorts(self.atomic0.outputs["elevator"], self.atomic2.input)
        self.connectPorts(self.atomic1.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Floor"], self.atomic1.obj_manager_in)
        self.connectPorts(self.atomic1.outputs["balls"], self.atomic3.input)
        self.connectPorts(self.atomic1.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic2.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Elevator"], self.atomic2.obj_manager_in)
        self.connectPorts(self.atomic2.outputs["balls"], self.atomic3.input)
        self.connectPorts(self.atomic2.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic3.obj_manager_out, self.objectmanager.input)
        self.connectPorts(self.objectmanager.output["Ball"], self.atomic3.obj_manager_in)
        self.connectPorts(self.atomic3.outputs["parent"], self.atomic0.input)
        self.connectPorts(self.atomic0.output, self.out_ui)
        self.connectPorts(self.atomic1.output, self.out_ui)
        self.connectPorts(self.atomic2.output, self.out_ui)
        self.connectPorts(self.atomic3.output, self.out_ui)